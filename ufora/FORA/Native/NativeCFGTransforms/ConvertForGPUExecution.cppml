#include "ConvertForGPUExecution.hppml"
#include "../NativeCode.hppml"
#include "../../../core/cppml/CPPMLTransform.hppml"

#include "../../../core/Logging.hpp"

namespace NativeCFGTransforms {

class IncrementReturnIndexTransformer {
public:
	IncrementReturnIndexTransformer(uword_t maxIdx) : mMaxIdx(maxIdx) {}

	template<class T>
	Nullable<T> processDown(const T& in, bool& out) const
		{
		return null();
		}
	template<class T>
	Nullable<T> processUp(const T& in) const
		{
		return null();
		}

	NativeExpression	processUp(const NativeExpression& inExp) const
		{
		LOG_DEBUG << "IncrementReturnIndexTr::processUp::NativeExpression:"
				<< prettyPrintString(inExp);
		@match NativeExpression(inExp)
			-|	Return(idx, val) ->> {
				if (idx < mMaxIdx)
					return NativeExpression::Return(idx+1, val);
				else
					return NativeExpression::Return(0, val);
				}
			-|	Call(f, continuations, args, meta) ->> {
				LOG_DEBUG << "Updating continuations of Call expr";
				NativeContinuation nullCont =
						NativeContinuation(
								NativeVariable::Temp(NativeType::Nothing()),
								NativeExpression::Return(0, NativeConstant::Nothing().expr()));
				@match NativeCallTarget(f)
				-|	Inline(fun, block) ->> {
					NativeCFG cfg(fun);
					cfg.returnTypes() =
							emptyTreeVec() + NativeType::Nothing() + cfg.returnTypes();
					LOG_DEBUG << "Added a Nothing as first return type of CFG " << cfg.name()
							<<". returnTypes.size = "
							<< cfg.returnTypes().size();
					for (auto t : cfg.returnTypes())
						LOG_DEBUG << "retTyp: " << prettyPrintString(t);
					return NativeExpression::Call(
							NativeCallTarget::Inline(cfg, block),
							emptyTreeVec() + nullCont + continuations,
							args,
							meta);
					}
				-|	_ ->> {
					return NativeExpression::Call(
							f,
							emptyTreeVec() + nullCont + continuations,
							args,
							meta);
					}
				}
			-|	Tagged(e, t) ->> {
				@match NativeExpressionTag(t)
					-|	HomogenousVectorLookup(vectorRecord, index, type) ->> {
						LOG_DEBUG << "unwrapping HomogenousVectorLookup tagged exp";
						LOG_DEBUG << "inExp::" << prettyPrintString(inExp);
//						LOG_DEBUG << "e::" << prettyPrintString(e);
						LOG_DEBUG << "t::" << prettyPrintString(t);
						LOG_DEBUG << "type: " << prettyPrintString(type);
						LOG_DEBUG << "vectorRecord.type(): " << prettyPrintString(vectorRecord.type());
						NativeExpression exp = NativeExpression::BinaryOp(
										NativeBinaryOpcode::Add(),
										vectorRecord,
										index
										);
						LOG_DEBUG << "resulting expression:" << prettyPrintString(exp);
						LOG_DEBUG << "resulting expression type:" << prettyPrintString(exp.type());
						return exp;
						}
					-| _ ->> {
						return inExp;
						}
				}
			-|	_ ->> {
				return inExp;
				}
			;
		}

private:
	uword_t mMaxIdx;
};

class StripIncompatibleForGpuTransformer {
public:
	template<class T>
	Nullable<T> processDown(const T& in, bool& out) const
		{
		return null();
		}
	template<class T>
	Nullable<T> processUp(const T& in) const
		{
		return null();
		}

	NativeExpression	processUp(const NativeExpression& t) const
		{
		@match NativeExpression(t)
			-|	Let(v, exp, within) ->> {
				if (exp.type())
					return t;
				else
					return NativeExpression::Return(0, NativeConstant::Nothing().expr());
				}
			-|	_ ->> {
				return t;
				}
			;
		}

	NativeExpression	processDown(const NativeExpression& inExp, bool& ioCont) const
		{
		@match NativeExpression(inExp)
			-|	Alloc(_) ->> {
				return mUnsupported;
				}
			-|	Selector(_) ->> {
				return mUnsupported;
				}
			-|	ElementAddress(_) ->> {
				return mUnsupported;
				}
			-|	CallLibraryFunction(_) ->> {
				return mUnsupported;
				}
			-|	Continuations(_) ->> {
				return mUnsupported;
				}
			-|	FollowContinuation(_) ->> {
				return mUnsupported;
				}
			-|	Halt()	->> {
				return mUnsupported;
				}
			-|	_ ->> {
				return inExp;
				}
			;
		}

	StripIncompatibleForGpuTransformer()
		{
		mUnsupported = NativeExpression::Return(0, NativeConstant::Nothing().expr());
		}
private:
	NativeExpression mUnsupported;
};

NativeCFG convertForGpuExecution(const NativeCFG& in, unsigned int resultPartSize)
	{
	NativeCFG cfg(in);
	cfg.returnTypes() =
			emptyTreeVec() + NativeType::Nothing() +
			cfg.returnTypes().slice(0, resultPartSize);
	cfg = transform(cfg, IncrementReturnIndexTransformer(resultPartSize));
	cfg = transform(cfg, StripIncompatibleForGpuTransformer());
	return cfg;
	}

}
