/***************************************************************************
   Copyright 2015 Ufora Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
****************************************************************************/
#include "NativeCode.hppml"

#include "../../core/math/Hash.hpp"
#include "../../core/math/UniqueIntegers.hpp"
#include "../../core/StringUtil.hpp"
#include <boost/lexical_cast.hpp>
#include "../../core/cppml/CPPMLVisit.hppml"
#include "../../core/STLOps.hpp"
#include "../../core/SymbolExport.hpp"
#include "../Runtime.hppml"
#include "../TypedFora/TypedFora.hppml"
#include "../TypedFora/ABI/NativeLayoutType.hppml"
#include "NativeCFGTransforms/Transforms.hppml"
#include "../Judgment/JudgmentOnValue.hppml"
#include "../TypedFora/ABI/ArbitraryNativeConstantForString.hpp"

NativeContinuationVarMetadataSerialized::NativeContinuationVarMetadataSerialized(
			const NativeContinuationExpressionSerialized& inData,
			const Nullable<CPPMLOpaqueHandle<TypedFora::Type> >& inLayout
			)
	{
	lassert_dump(
		!inLayout || TypedFora::Abi::nativeTypeForForaType(**inLayout) == inData.type(),
		"Created metadata with incorrect typing information:\n"
		<< "TypedFora::Type: " << prettyPrintString(*inLayout) << "\n"
		<< "TypedFora::Type's NativeType: "
		<< prettyPrintString(TypedFora::Abi::nativeTypeForForaType(**inLayout)) << "\n"
		<< "Data: " << prettyPrintString(inData) << "\n"
		<< "Data's NativeType: " << prettyPrintString(inData.type()) << "\n"
		)


	data() = inData;
	layout() = inLayout;
	toss() = false;
	}

NativeType NativeContinuationExpressionSerialized::computeNativeType(void) const
	{
	@match NativeContinuationExpressionSerialized(*this)
		-| Leaf(t, _) ->> {
			return t;
			}
		-| Constant(c, subtype, offset) ->> {
			return subtype;
			}
		-| Tuple(children) ->> {
			ImmutableTreeVector<NativeType> types;

			for (long k = 0; k < children.size(); k++)
				types = types + children[k].type();

			return NativeType::Composite(types);
			}
	}

NativeContinuationExpressionSerialized
NativeContinuationExpressionSerialized::Constant(const NativeConstant& c)
	{
	return Constant(c, c.type(), 0);
	}


NativeContinuationVarMetadata::NativeContinuationVarMetadata(
		const NativeExpression& inData
		)
	{
	dataVar() = inData;
	toss() = false;
	}

NativeContinuationVarMetadata::NativeContinuationVarMetadata(
			const NativeExpression& inData,
			const TypedFora::Type& inLayout
			)
	{
	dataVar() = inData;
	layout() = CPPMLOpaqueHandle<TypedFora::Type>(inLayout);

	lassert(!inData.type() || TypedFora::Abi::nativeTypeForForaType(inLayout) == *inData.type());

	toss() = false;
	}

NativeContinuationVarMetadata::NativeContinuationVarMetadata(
			const NativeExpression& inData,
			const CPPMLOpaqueHandle<TypedFora::Type>& inLayout
			)
	{
	dataVar() = inData;
	layout() = inLayout;

	if (inData.type())
		lassert_dump(
			TypedFora::Abi::nativeTypeForForaType(*inLayout) == *inData.type(),
			"Expected " << prettyPrintString(*inLayout) << " to have layout "
				<< prettyPrintString(TypedFora::Abi::nativeTypeForForaType(*inLayout))
				<< " but instead found data of type "
				<< prettyPrintString(*inData.type())
			);

	toss() = false;
	}



NativeExpression NativeExpression::cast(const NativeType& inType, bool forceBitcast) const
	{
	if (type() && *type() == inType)
		return *this;
	return NativeExpression::Cast(inType, *this, forceBitcast);
	}
NativeExpression NativeExpression::offsetLoad(uword_t offset, NativeType elemType) const
	{
	return this->cast(NativeType::uint8().ptr(), false)[offset].cast(elemType.ptr(), false).load();
	}
Nullable<NativeType> contListType(const ImmutableTreeVector<NativeContinuation>& conts)
	{
	Nullable<NativeType> t;
	for (long k = 0; k < conts.size();k++)
		if (conts[k].expression().type())
			{
			if (!t)
				t = conts[k].expression().type();
				else
				{
				lassert(t == conts[k].expression().type());
				}
			}
	return t;
	}
Nullable<NativeType>	NativeExpression::computeNativeType(void) const
	{
	@match NativeExpression(*this)
		-|	Constant(c) ->> {
			@match NativeConstant(c)
				-|	Double() ->> {
					return  null() << NativeType::Float(64);
					}
				-|	Float() ->> {
					return  null() << NativeType::Float(32);
					}
				-|	Bool() ->> {
					return  null() << NativeType::uint1();
					}
				-|	UInt8() ->> {
					return  null() << NativeType::uint8();
					}
				-|	UInt16() ->> {
					return  null() << NativeType::uint16();
					}
				-|	UInt32() ->> {
					return  null() << NativeType::uint32();
					}
				-|	UInt64() ->> {
					return  null() << NativeType::uint64();
					}
				-|	Int8() ->> {
					return  null() << NativeType::int8();
					}
				-|	Int16() ->> {
					return  null() << NativeType::int16();
					}
				-|	Int32() ->> {
					return  null() << NativeType::int32();
					}
				-|	Int64() ->> {
					return  null() << NativeType::int64();
					}
				-|	NullPointer(pointedToType) ->> {
					return  null() << pointedToType.ptr();
					}
				-|	VoidPtr() ->> {
					return  null() << NativeType::Nothing().ptr();
					}
				-|	Nothing() ->> {
					return  null() << NativeType::Nothing();
					}
				-|	Composite(constants) ->> {
					ImmutableTreeVector<NativeType> types;

					for (auto c: constants)
						types = types + c.type();

					return null() << NativeType::Composite(types);
					}
				-|	ArbitraryConstant(c) ->> {
					return  null() << c->nativeType();
					}
				;
			}
		-|	Tagged(e) ->> { return e.type(); }
		-|	Variable(v) ->> { return null() << v.type(); }
		-|	CreateComposite(elts) ->> {
				ImmutableTreeVector<NativeType> ts;
				bool OK = true;
				for (long k = 0; k < elts.size() && OK; k++)
					if (elts[k].type())
						ts = ts + *elts[k].type();
						else
						OK = false;
				if (OK)
					return null() << NativeType::Composite(ts);
				return null();
				}
		-|	DiscardFirst(f,s) ->> { return f.type() ? s.type() : f.type(); }
		-|	Load(v,isVol) ->> { return v.type() && v.type()->isPointer() ? null() << v.type()->getPointer().element() : Nullable<NativeType>(); }
		-|	Zero(t) ->> { return null() << t; }
		-|	Alloc(t,_,_) ->> { return null() << t.ptr(); }
		-|	Store(addr, val) ->> { return addr.type() && val.type() ? null() << NativeType::Nothing() : Nullable<NativeType>(); }
		-|	Selector(c,t,f) ->> { return !(c.type() && t.type() && f.type()) ? Nullable<NativeType>() : t.type(); }
		-|	If(c,t,f) ->> {
			if (t.type() && f.type())
				lassert_dump(*t.type() == *f.type(),
					"If expression had inconsistent types. "
						<< prettyPrintString(*t.type()) << " != "
						<< prettyPrintString(*f.type()) << ":\n"
						<< prettyPrintString(t) << " vs " << prettyPrintString(f)
					);
			if (c.type())
				lassert_dump(c.type()->isInteger() || c.type()->isFloat() || c.type()->isPointer(),
					"can't branch on a value of type " << prettyPrintString(*c.type())
					);

			return !c.type() ? Nullable<NativeType>() : !t.type() ? f.type() : t.type();
			}
		-|	Let(v,e,w) ->> {
				if (e.type())
					lassert_dump(v.type() == *e.type(),
						"invalid let binding. can't assign type "
							<< prettyPrintString(*e.type()) << " to variable of "
							<< prettyPrintString(v.type()) << ". expr = \n"
							<< prettyPrintString(e) << "\nbound to " << prettyPrintString(v) << "\nwithin "
							<< prettyPrintString(w) << "\n"
							<< prettyPrintString(v.type().hash()) << " vs. " << prettyPrintString(e.type()->hash())
							<< ". cmp = " << (long)cppmlCmp(v.type(), *e.type()) << "\n"
							<< ". cmp = " << (long)cppmlCmp(v.type().hash(), e.type()->hash()) << "\n"
							);

				return !e.type() ? Nullable<NativeType>() : w.type();
				}
		-|	BinaryOp(opcode,lhs,rhs) ->> {
                return !lhs.type() || !rhs.type() ? Nullable<NativeType>() : opcode.isComparison() ? null() << NativeType::uint1() : lhs.type();
                }
		-|	UnaryOp(Negate(), lhs) ->> {
				lassert_dump(!lhs.type() ||
						(lhs.type()->isInteger() && lhs.type()->getInteger().isSigned()
							|| lhs.type()->isFloat()),
					prettyPrintString(*lhs.type())
						<< " isn't a valid type for 'negate'. only signed ints or floats");
				return lhs.type();
				}
		-|	UnaryOp(NOT(), lhs) ->> {
				lassert_dump(!lhs.type() || lhs.type()->isInteger(),
					prettyPrintString(*lhs.type())
						<< " isn't a valid type for 'NOT'. only ints");
				return lhs.type();
				}
		-|	UnaryOp(op, lhs) ->> {
				lassert_dump(!lhs.type() ||
						lhs.type()->isFloat() && lhs.type()->getFloat().bits() == 64,
					prettyPrintString(*lhs.type())
						<< " isn't a valid type for " << prettyPrintString(op) << ". only Float64");
				return lhs.type();
				}
		-|	Cast(dest, src) ->> {
				return src.type() ? null() << dest : Nullable<NativeType>();
				}
		-|	ElementAddress(elements, source) ->> {

				Nullable<NativeType> t = source.type();

				for (long k = 0; k < elements.size() && t; k++)
					{
					if (!elements[k].type())
						t = null();
						else
						{
						@match NativeType(*t)
							-|	Pointer(x) ->> {
								t = null() << x;
								}
							-|	Array(x) ->> {
								t = null() << x;
								}
							-|	_ ->> {
								@match Nullable<uint64_t>(elements[k].integerConstant())
									-|	Value(v)->> {
										@match NativeType(*t)
											-|	Composite(elts) ->> {
												t = null() << (elts[v]);
												}
											-|	x ->> {
												lassert_dump(false,
													"can't grab "
														<< prettyPrintString(v)
														<< "\nof item of type " << prettyPrintString(*t)
														<< "\nin "
														<< prettyPrintString(*this)
														<< "\nsource type = "
														<< prettyPrintString(*source.type())
													);
												t = null() <<  NativeType();
												}
											;
										}
									-|	Null() ->> {
										lassert_dump(false,
											"can't use "
												<< prettyPrintString(elements[k])
												<< "\nof type " << prettyPrintString(elements[k].type())
												<< "\nas elementAddress expression for\n"
												<< prettyPrintString(*t)
											);
										t = null() <<  NativeType();
										}
									;
								}
							;
						}
					}
				return t ?
					null() << t->ptr()
				:	t;
				}
		-|	ValueExtract(elements, source) ->> {
				if (!source.type())
					return null();
				return null() << *nativeTypeForValueExtractExpression(elements, *source.type());
				}
		-|	CallLibraryFunction(_, ret, args) ->> {
				bool OK = true;
				for (long k = 0; k < args.size() && OK;k++)
					OK = args[k].type().isValue();
				if(OK)
					return null() << ret;
				return null();
				}
		-|	Continuations(cont, meta) ->> {
				ImmutableTreeVector<NativeType> ts;
				for (long k = 0; k < cont.size();k++)
					ts = ts + cont[k].var().type();
				return null() << NativeType::Continuations(ts);
				}
		-|	Call(Inline(cfg, blockID),conts,args) ->> {
				return contListType(conts);
				}
		-|	Call(f,conts,args) ->> {
				return contListType(conts);
				}
		-|	Jump() ->> { return Nullable<NativeType>(); }
		-|	FollowContinuation() ->> { return Nullable<NativeType>(); }
		-|	Return() ->> { return Nullable<NativeType>(); }
		-|	Halt() ->> { return Nullable<NativeType>(); }
		;
	}

@type NativeReturnTypeExtractor = ImmutableTreeMap<uint64_t, NativeType> elts {
public:
		template<class T>
		void processDown(const T& in, bool& shouldContinue)
			{
			}
		template<class T>
		void processUp(const T& in)
			{
			}

		void processDown(const NativeExpression& in, bool& shouldContinue)
			{
			@match NativeExpression(in)
				-|	Return(exit, expr) ->> {
						if (expr.type())
							{
							if (elts()[exit])
								lassert_dump(*elts()[exit] == *expr.type(), "function returned from slot " << exit << " with two different types!");

							elts() = elts() + make_pair(exit, *expr.type());
							}
						}
				-|	_ ->> {;};
			}
		void processDown(const NativeCallTarget& t, bool& shouldContinue)
			{
			if (t.isInline())
				shouldContinue = false;
			}
};

ImmutableTreeMap<uint64_t, NativeType> extractReturnTypes(const NativeExpression& expr)
	{
	NativeReturnTypeExtractor f;
	visit(expr, f);
	return f.elts();
	}

@type NativeJumpTargetExtractor = ImmutableTreeVector<pair<NativeBlockID, ImmutableTreeVector<NativeType> > > elts {
public:
		template<class T>
		void processDown(const T& in, bool& shouldContinue)
			{
			}
		template<class T>
		void processUp(const T& in)
			{
			}

		void processDown(const NativeExpression& in, bool& shouldContinue)
			{
			@match NativeExpression(in)
				-|	Jump(target, expressions) ->> {
						ImmutableTreeVector<NativeType> types;

						for (long k = 0; k < expressions.size(); k++)
							{
							if (!expressions[k].type())
								return;

							types = types + *expressions[k].type();
							}

						elts() = elts() + make_pair(target, types);
						}
				-|	_ ->> {;};
			}
		void processDown(const NativeCallTarget& t, bool& shouldContinue)
			{
			if (t.isInline())
				shouldContinue = false;
			}
};

ImmutableTreeVector<pair<NativeBlockID, ImmutableTreeVector<NativeType> > > extractJumpTargets(const NativeExpression& expr)
	{
	NativeJumpTargetExtractor f;
	visit(expr, f);
	return f.elts();
	}

NativeCFG::NativeCFG(const ImmutableTreeVector<NativeType>& inRet, const ImmutableTreeMap<NativeBlockID, NativeBlock>& inBlocks, string inName)
	{
	toss() = false;
	returnTypes() = inRet;
	blocks() = inBlocks;
	name() = inName;

	//validate();
	}

NativeCFG::NativeCFG(const ImmutableTreeVector<NativeType>& inRet, const ImmutableTreeVector<NativeVariable>& inArgs, const NativeExpression& inExpr, string n)
	{
	toss() = false;
	returnTypes() = inRet;

	name() = n;
	lassert(!inExpr.type());

	blocks() = blocks() + NativeBlockID::entry() + NativeBlock(inArgs, inExpr);

	//validate();
	}

NativeCFG::NativeCFG(const ImmutableTreeVector<NativeVariable>& inArgs, const NativeExpression& inExpr, string n)
	{
	toss() = false;
	name() = n;
	if (inExpr.type())
		{
		returnTypes() = returnTypes() + *inExpr.type();
		blocks() = blocks() + NativeBlockID::entry() + NativeBlock(inArgs, NativeExpression::Return(0,inExpr));
		lassert_dump(extractReturnTypes(inExpr).size() == 0, prettyPrintString(inExpr) << " had type, but also a return of type " << prettyPrintString(extractReturnTypes(inExpr)));
		}
	else
		{
		ImmutableTreeMap<uint64_t, NativeType> ts = extractReturnTypes(inExpr);
		for (uint64_t k = 0; k < ts.size();k++)
			{
			lassert_dump(ts[k], "missing return slot " << k << " in " << prettyPrintString(inExpr));
			returnTypes() = returnTypes() + *ts[k];
			}

		blocks() = blocks() + NativeBlockID::entry() + NativeBlock(inArgs, inExpr);
		}

	//validate();
	}
NativeExpression operator*=(const NativeExpression& left, const NativeExpression& toStore)
	{
	return NativeExpression::Store(left, toStore);
	}
@type InvalidNativeCallTarget = string msg;

@type NativeCallTargetValidationVisitor = const NativeCFG* fun {
public:
	map<NativeVariable, uint64_t> mVarsDefined;

	template<class T>
	void processDown(const T& in, bool& shouldContinue)
		{
		}
	template<class T>
	void processUp(const T& in)
		{
		}
	void processDown(const NativeContinuation& in, bool& shouldContinue)
		{
		shouldContinue = false;
		@match NativeContinuation(in)
			-|	(v,x) ->> {
				if (v == mVarsDefined)
					throw InvalidNativeCallTarget("variable " + prettyPrintString(v) + " is defined twice!");

				mVarsDefined[v]++;
				visit(x, *this);
				mVarsDefined[v]--;
				if (mVarsDefined[v] == 0)
					mVarsDefined.erase(v);
				}
			;
		}
	void processDown(const NativeExpression& in, bool& shouldContinue)
		{
		@match NativeExpression(in)
			-|	Call(Inline(f, b), rets, args) ->> {

				shouldContinue = false;

				if (f.returnTypes().size() != rets.size())
					throw InvalidNativeCallTarget(
						"didn't pass enough continuations to " + prettyPrintString(f) +
						". " + prettyPrintString(f.returnTypes()) +
						" != " + prettyPrintString(rets)
						);

				for (long k = 0; k < rets.size();k++)
					if (f.returnTypes()[k] != rets[k].var().type())
						throw InvalidNativeCallTarget(
							"passed wrong continuation type:\n\t" +
								prettyPrintString(rets[k].var().type()) +
								"\nto function expecting" +
								prettyPrintString(f.returnTypes()[k]) +
								"\nin slot " + boost::lexical_cast<string>(k) + "\nf = " +
								prettyPrintString(f)
							);

				if (!f.blocks()[b])
					throw InvalidNativeCallTarget("tried to jump to " +
						prettyPrintString(b) +
						" which doesn't exit in \n\n" +
						prettyPrintString(f));

				const NativeBlock& entBlock = *f.blocks()[b];

				if (args.size() != entBlock.args().size())
					throw InvalidNativeCallTarget(
						"didn't pass right number of arguments to " +
						prettyPrintString(f) + ". " +
						prettyPrintString(entBlock.args()) +
						" != " + prettyPrintString(args)
						);

				for (long k = 0; k < args.size();k++)
					{
					visit(args[k], *this);
					if (args[k].type() && *args[k].type() != entBlock.args()[k].type())
						throw InvalidNativeCallTarget(
							"passed wrong arg type to " +
							prettyPrintString(f) + " in slot " +
							boost::lexical_cast<string>(k)
							);
					}
				}
			-|	Call(f, rets, args) ->> {
				shouldContinue = false;
				//rets need to either have same out type or be empty
				Nullable<NativeType> t;
				for (long k = 0; k < rets.size();k++)
					{
					if (rets[k].expression().type())
						{
						if (!t)
							t = rets[k].expression().type();
							else
						if (t != rets[k].expression().type())
							throw InvalidNativeCallTarget(
								"in call to " +
								prettyPrintString(f) + " continuation " +
								boost::lexical_cast<string>(k) +
								" has conflicting return type"
								);
						}
					visit(rets[k], *this);
					}
				visit(args, *this);
				}
			-|	Continuations(conts, meta) ->> {
				shouldContinue = false;
				for (long k = 0; k < conts.size();k++)
					if (conts[k].expression().type())
						throw InvalidNativeCallTarget(
							"continuation created in 'Continuations' should not "
							"continue flow control"
							);
				}
			-|	Let(v, within, x) ->> {
				shouldContinue = false;

				visit(within, *this);

				mVarsDefined[v]++;
				visit(x, *this);
				mVarsDefined[v]--;
				if (mVarsDefined[v] == 0)
					mVarsDefined.erase(v);

				}
			-|	Jump(id, args) ->> {
				if (!fun()->blocks()[id])
					throw InvalidNativeCallTarget("target of jump doesn't exist");
				const NativeBlock& b = *fun()->blocks()[id];

				if (args.size() != b.args().size())
					throw InvalidNativeCallTarget(
						"jump to " + prettyPrintString(id) +
						" has wrong arg count (" + prettyPrintString(args.size()) +
							" instead of " + prettyPrintString(b.args().size()) + ")"
						);

				for (long k = 0; k < args.size(); k++)
					if (args[k].type() && *args[k].type() != b.args()[k].type())
						throw InvalidNativeCallTarget(
							"passed wrong arg type during jump to " + prettyPrintString(id) +
							" in slot " + boost::lexical_cast<string>(k)
							);
				}
			-|	_ ->> {;}
			;
		}

};

const NativeBlock& NativeCFG::operator[](const NativeBlockID& n)  const
	{
	lassert_dump(
		blocks()[n],
		"cfg\n" << Ufora::indent(prettyPrintString(*this))
			<< "\ndoesn't have block " << prettyPrintString(n) << "\n"
		);
	return *blocks()[n];
	}

void	NativeCFG::validate(void) const
	{
	try {
		NativeCallTargetValidationVisitor vis(this);
		for (long k = 0; k < blocks().size();k++)
			visit(blocks().pairAtPosition(k).second, vis);


		//validate our return statements
		for (long k = 0; k < blocks().size();k++)
			{
			auto block = blocks().pairAtPosition(k).second;

			ImmutableTreeMap<uint64_t, NativeType> blockReturns =
				extractReturnTypes(block.expression());

			for (long j = 0; j < blockReturns.size();j++)
				{
				uint64_t returnIndex = blockReturns.pairAtPosition(j).first;
				NativeType returnType = blockReturns.pairAtPosition(j).second;

				if (returnIndex >= returnTypes().size())
					throw InvalidNativeCallTarget(
						"Control flow graph returns to index " +
							boost::lexical_cast<string>(returnIndex) + " which is "
							"out of range in " + prettyPrintString(returnTypes())
						);

				if (returnTypes()[returnIndex] != returnType)
					throw InvalidNativeCallTarget(
						"Control flow graph returns " + prettyPrintString(returnType) +
							" to return index " +
							boost::lexical_cast<string>(returnIndex) + " which expects " +
							prettyPrintString(returnTypes()[returnIndex])
						);
				}
			}

		//validate our jumps
		for (long k = 0; k < blocks().size(); k++)
			{
			auto block = blocks().pairAtPosition(k).second;

			ImmutableTreeVector<pair<NativeBlockID, ImmutableTreeVector<NativeType> > > jumpTargets =
				extractJumpTargets(block.expression());

			for (long j = 0; j < jumpTargets.size(); j++)
				{
				NativeBlockID target = jumpTargets[j].first;
				ImmutableTreeVector<NativeType> types = jumpTargets[j].second;

				lassert_dump(
					blocks().contains(target),
					"block " << prettyPrintString(block) << " tried to jump to non-existent "
						<< "block " << prettyPrintString(target)
					);

				lassert_dump(
					varsToTypes(blocks()[target]->args()) == types,
					"Block " << prettyPrintString(block) << " jumped to block "
						<< prettyPrintString(target) << " with arguments of type "
						<< prettyPrintString(types) << ", but that block accepts "
						<< prettyPrintString(varsToTypes(blocks()[target]->args()))
					);
				}
			}
		}
	catch(InvalidNativeCallTarget e)
		{
		lassert_dump(false, "function was invalid because " << prettyPrintString(e.msg()) << "\nfun = " << prettyPrintString(*this));
		}
	}

template<class T1, class T2>
ImmutableTreeSet<NativeBlockID>	jumpTargets(const pair<T1, T2>& inExpr)
	{
	return jumpTargets(inExpr.first) + jumpTargets(inExpr.second);
	}
template<class T>
ImmutableTreeSet<NativeBlockID>	jumpTargets(const Nullable<T>& inExpr)
	{
	if (inExpr)
		return jumpTargets(*inExpr);
	return ImmutableTreeSet<NativeBlockID>();
	}
template<class T>
ImmutableTreeSet<NativeBlockID>	jumpTargets(const ImmutableTreeVector<T>& inExpr)
	{
	ImmutableTreeSet<NativeBlockID> tr;
	for (long k = 0; k < inExpr.size(); k++)
		tr = tr + inExpr[k].jumpTargets();
	return tr;
	}

ImmutableTreeSet<NativeBlockID>	NativeCallTarget::jumpTargets(void) const
	{
	@match NativeCallTarget(*this)
		-|	Inline(f) ->> {
			return  emptyTreeSet();
			}
		-| 	Expansion() ->> {
			return emptyTreeSet();
			}
		-|	External(t,b) ->> {
			return  emptyTreeSet();
			}
		-|	Pointer(e) ->> {
			return e.jumpTargets();
			}
		;
	}
NativeExpression NativeExpression::ElementAddress(
				const ImmutableTreeVector<NativeExpression>& element,
				const NativeExpression& source
				)
	{
	NativeExpression tr = NativeExpression::ElementAddress(element, source, false);
	tr.type();
	return tr;
	}
ImmutableTreeSet<NativeBlockID>		NativeExpression::computeJumpTargets(void) const
	{
	@match NativeExpression(*this)
		-|	Constant(v) ->> {
			return emptyTreeSet();
			}
		-|	Variable(v) ->> {
			return emptyTreeSet();
			}
		-|	Tagged(e) ->> {
			return e.jumpTargets();
			}
		-|	CreateComposite(x) ->> {
			return ::jumpTargets(x);
			}
		-|	DiscardFirst(x,y) ->> {
			return x.jumpTargets() + y.jumpTargets();
			}
		-|	Load(x) ->> {
			return x.jumpTargets();
			}
		-|	Zero() ->> {
			return emptyTreeSet();
			}
		-|	Alloc() ->> {
			return emptyTreeSet();
			}
		-|	Store(x,y) ->> {
			return x.jumpTargets() + y.jumpTargets();
			}
		-|	Selector(x,y,z) ->> {
			return x.jumpTargets() + y.jumpTargets() + z.jumpTargets();
			}
		-|	If(x,y,z) ->> {
			return x.jumpTargets() + y.jumpTargets() + z.jumpTargets();
			}
		-|	Let(var, e, w) ->> {
			return e.jumpTargets() + w.jumpTargets();
			}
		-|	BinaryOp(_,x,y) ->> {
			return x.jumpTargets() + y.jumpTargets();
			}
		-|	UnaryOp(_,x) ->> {
			return x.jumpTargets();
			}
		-|	Cast(_,x) ->> {
			return x.jumpTargets();
			}
		-|	ElementAddress(x,y) ->> {
			return ::jumpTargets(x) + y.jumpTargets();
			}
		-|	ValueExtract(_,x) ->> {
			return x.jumpTargets();
			}
		-|	CallLibraryFunction(_,_,x) ->> {
			return ::jumpTargets(x);
			}
		-|	Continuations(x,data) ->> {
			return ::jumpTargets(x);
			}
		-|	Call(t,h,a) ->> {
			return t.jumpTargets() + ::jumpTargets(h) + ::jumpTargets(a);
			}
		-|	Jump(target,e) ->> {
			return (emptyTreeSet() + target);
			}
		-|	FollowContinuation(v,c,i) ->> {
			return v.jumpTargets() + c.jumpTargets();
			}
		-|	Return(_,v) ->> {
			return v.jumpTargets();
			}
		-|	Halt() ->> {
			return emptyTreeSet();
			}
		;
	}
ImmutableTreeSet<NativeBlockID>		NativeContinuation::jumpTargets(void) const
	{
	return expression().jumpTargets();
	}

namespace {
ImmutableTreeSet<string> getExternalBranchesFromBlock(const NativeBlock& b)
	{
	return b.expression().externalBranches();
	}
}

ImmutableTreeSet<string>				NativeCFG::externalBranches(void) const
	{
	return blocks().sumValues(getExternalBranchesFromBlock);
	}


ImmutableTreeSet<string>	NativeCallTarget::externalBranches(void) const
	{
	@match NativeCallTarget(*this)
		-|	Inline(f) ->> {
			return f.blocks().sumValues(getExternalBranchesFromBlock);
			}
		-|	Expansion() ->> {
			return emptyTreeSet();
			}
		-|	External(t,b) ->> {
			return  emptyTreeSet() + t;
			}
		-|	Pointer(e) ->> {
			return  e.externalBranches();
			}
		;
	}
ImmutableTreeSet<uword_t>	NativeCallTarget::exits(void) const
	{
	@match NativeCallTarget(*this)
		-|	Inline() ->> {
			return  emptyTreeSet();
			}
		-|	Expansion() ->> {
			return emptyTreeSet();
			}
		-|	External(t,b) ->> {
			return  emptyTreeSet();
			}
		-|	Pointer(e) ->> {
			return  e.exits();
			}
		;
	}

template<class T1, class T2>
ImmutableTreeSet<NativeVariable>	freeVariables(const pair<T1, T2>& inExpr)
	{
	return freeVariables(inExpr.first) + freeVariables(inExpr.second);
	}
template<class T>
ImmutableTreeSet<NativeVariable>	freeVariables(const Nullable<T>& inExpr)
	{
	if (inExpr)
		return freeVariables(*inExpr);
	return ImmutableTreeSet<NativeVariable>();
	}


template<class T>
ImmutableTreeSet<NativeVariable>	freeVariables(const ImmutableTreeVector<T>& inExpr)
	{
	ImmutableTreeSet<NativeVariable> tr;

	for (long k = 0; k < inExpr.size(); k++)
		tr = tr + inExpr[k].freeVariables();
	return tr;
	}

ImmutableTreeSet<NativeVariable>	NativeCallTarget::freeVariables(void) const
	{
	@match NativeCallTarget(*this)
		-|  Expansion() ->> {
			return emptyTreeSet();
			}
		-|	Inline(f) ->> {
			return  f.freeVariables();
			}
		-|	External(t,b) ->> {
			return  emptyTreeSet();
			}
		-|	Pointer(e) ->> {
			return  e.freeVariables();
			}
		;
	}

bool	NativeCallTarget::hasSideEffects(void) const
	{
	@match NativeCallTarget(*this)
		-| 	Expansion((_, _, hasSideEffects)) ->> {
			return hasSideEffects;
			}
		-|	Inline(f) ->> {
			return  f.hasSideEffects();
			}
		-|	External(t,b) ->> {
			return  true;
			}
		-|	Pointer(e) ->> {
			return  true;
			}
		;
	}

bool	NativeExpression::computeHasSideEffects(void) const
	{
	@match NativeExpression(*this)
		-|	Constant(v) ->> {
			return  false;
			}
		-|	Variable(v) ->> {
			return  false;
			}
		-|	Tagged(e) ->> {
			return  e.hasSideEffects();
			}
		-|	CreateComposite(x) ->> {
			for (long k = 0; k < x.size();k++)
				if (x[k].hasSideEffects())
					return true;
			return false;
			}
		-|	DiscardFirst(x,y) ->> {
			return x.hasSideEffects() || y.hasSideEffects();
			}
		-|	Load(x) ->> {
			return  x.hasSideEffects();
			}
		-|	Zero() ->> {
			return  false;
			}
		-|	Alloc() ->> {
			return false;
			}
		-|	Store(x,y) ->> {
			return  true;
			}
		-|	Selector(x,y,z) ->> { return x.hasSideEffects() || y.hasSideEffects() || z.hasSideEffects(); }
		-|	If(x,y,z) ->>  { return x.hasSideEffects() || y.hasSideEffects() || z.hasSideEffects(); }
		-|	Let(var, e, w) ->>  { return e.hasSideEffects() || w.hasSideEffects(); }
		-|	BinaryOp(_,x,y) ->>  { return x.hasSideEffects() || y.hasSideEffects(); }
		-|	UnaryOp(_,x) ->> {
			return  x.hasSideEffects();
			}
		-|	Cast(_,x) ->> {
			return  x.hasSideEffects();
			}
		-|	ElementAddress(x,y) ->> {
			for (long k = 0; k < x.size();k++)
				if (x[k].hasSideEffects())
					return true;

			return y.hasSideEffects();
			}
		-|	ValueExtract(_,x) ->> {
			return  x.hasSideEffects();
			}
		-|	CallLibraryFunction(_,_,x) ->> {
			return  true;
			}
		-|	Continuations(x,data) ->> {
			for (long k = 0; k < x.size();k++)
				if (x[k].hasSideEffects())
					return true;
			return false;
			}
		-|	Call(t,h,a,m) ->> {
			for (long k = 0; k < h.size();k++)
				if (h[k].hasSideEffects())
					return true;
			for (long k = 0; k < a.size();k++)
				if (a[k].hasSideEffects())
					return true;

			return t.hasSideEffects();
			}
		-|	Jump(_,e) ->> {
			for (long k = 0; k < e.size();k++)
				if (e[k].hasSideEffects())
					return true;
			return false;
			}
		-|	FollowContinuation(v,c,i) ->> {
			return  true;
			}
		-|	Return(_,v) ->> {
			return  v.hasSideEffects();
			}
		-|	Halt() ->> {
			return  true;
			}
		;
	}
ImmutableTreeSet<NativeVariable>	NativeExpression::computeFreeVariables(void) const
	{
	@match NativeExpression(*this)
		-|	Constant(v) ->> {
			return  emptyTreeSet();
			}
		-|	Variable(v) ->> {
			return  emptyTreeSet() + v;
			}
		-|	Tagged(e) ->> {
			return  e.freeVariables();
			}
		-|	CreateComposite(x) ->> {
			return  ::freeVariables(x);
			}
		-|	DiscardFirst(x,y) ->> {
			return  x.freeVariables() + y.freeVariables();
			}
		-|	Load(x) ->> {
			return  x.freeVariables();
			}
		-|	Zero() ->> {
			return  emptyTreeSet();
			}
		-|	Alloc(_, x) ->> {
			return emptyTreeSet();
			}
		-|	Store(x,y) ->> {
			return  x.freeVariables() + y.freeVariables();
			}
		-|	Selector(x,y,z) ->> {
			return  x.freeVariables() + y.freeVariables() + z.freeVariables();
			}
		-|	If(x,y,z) ->> {
			return  x.freeVariables() + y.freeVariables() + z.freeVariables();
			}
		-|	Let(var, e, w) ->> {
			return  e.freeVariables() + (w.freeVariables() - var);
			}
		-|	BinaryOp(_,x,y) ->> {
			return  x.freeVariables() + y.freeVariables();
			}
		-|	UnaryOp(_,x) ->> {
			return  x.freeVariables();
			}
		-|	Cast(_,x) ->> {
			return  x.freeVariables();
			}
		-|	ElementAddress(x,y) ->> {
			return  ::freeVariables(x) + y.freeVariables();
			}
		-|	ValueExtract(_,x) ->> {
			return  x.freeVariables();
			}
		-|	CallLibraryFunction(_,_,x) ->> {
			return  ::freeVariables(x);
			}
		-|	Continuations(x,data) ->> {
			return  ::freeVariables(x) + ::freeVariables(data);
			}
		-|	Call(t,h,a,m) ->> {
			return  t.freeVariables() + ::freeVariables(h) + ::freeVariables(a) + ::freeVariables(m);
			}
		-|	Jump(_,e) ->> {
			return  ::freeVariables(e);
			}
		-|	FollowContinuation(v,c,i) ->> {
			return  v.freeVariables() + c.freeVariables();
			}
		-|	Return(_,v) ->> {
			return  v.freeVariables();
			}
		-|	Halt() ->> {
			return  emptyTreeSet();
			}
		;
	}
ImmutableTreeSet<NativeVariable>	NativeContinuationMetadata::freeVariables(void) const
	{
	ImmutableTreeSet<NativeVariable> tr;

	for (long k = 0; k < vars().size(); k++)
		tr = tr + vars()[k].dataVar().freeVariables()
				;

	return tr;
	}
ImmutableTreeSet<NativeVariable>	NativeContinuation::freeVariables(void) const
	{
	return expression().freeVariables() - var();
	}
bool	NativeContinuation::hasSideEffects(void) const
	{
	return expression().hasSideEffects();
	}
ImmutableTreeSet<NativeVariable>		NativeCFG::freeVariables(void) const
	{
	ImmutableTreeSet<NativeVariable> vars;
	for (long k = 0; k < blocks().size();k++)
		{
		const NativeBlock& b(blocks().pairAtPosition(k).second);
		ImmutableTreeSet<NativeVariable> toAdd = b.expression().freeVariables();
		for (long j = 0; j < b.args().size();j++)
			toAdd = toAdd - b.args()[j];
		vars = vars + toAdd;
		}
	return vars;
	}
bool		NativeCFG::hasSideEffects(void) const
	{
	for (long k = 0; k < blocks().size();k++)
		{
		if (blocks().pairAtPosition(k).second.expression().hasSideEffects())
			return true;
		}
	return false;
	}



template<class T1, class T2>
ImmutableTreeSet<string>	externalBranches(const pair<T1, T2>& inExpr)
	{
	return externalBranches(inExpr.first) + externalBranches(inExpr.second);
	}

template<class T>
ImmutableTreeSet<string>	externalBranches(const Nullable<T>& inExpr)
	{
	if (inExpr)
		return externalBranches(*inExpr);
	return ImmutableTreeSet<string>();
	}

ImmutableTreeSet<string>	externalBranches(const ImmutableTreeVector<NativeExpression>& inExpr)
	{
	ImmutableTreeSet<string> tr;
	for (long k = 0; k < inExpr.size();k++)
		tr = tr + inExpr[k].externalBranches();
	return tr;
	}

ImmutableTreeSet<string>	externalBranches(const ImmutableTreeVector<NativeContinuation>& inExpr)
	{
	ImmutableTreeSet<string> tr;
	for (long k = 0; k < inExpr.size();k++)
		tr = tr + inExpr[k].externalBranches();
	return tr;
	}
ImmutableTreeSet<string>			NativeExpression::computeExternalBranches(void) const
	{
	@match NativeExpression(*this)
		-|	Constant(v) ->> {
			return  emptyTreeSet();
			}
		-|	Variable(v) ->> {
			return  emptyTreeSet();
			}
		-|	Tagged(e) ->> {
			return  e.externalBranches();
			}
		-|	CreateComposite(x) ->> {
			return  ::externalBranches(x);
			}
		-|	DiscardFirst(x,y) ->> {
			return  x.externalBranches() + y.externalBranches();
			}
		-|	Load(x) ->> {
			return  x.externalBranches();
			}
		-|	Zero() ->> {
			return  emptyTreeSet();
			}
		-|	Alloc(_, x) ->> {
			return emptyTreeSet();
			}
		-|	Store(x,y) ->> {
			return  x.externalBranches() + y.externalBranches();
			}
		-|	Selector(x,y,z) ->> {
			return  x.externalBranches() + y.externalBranches() + z.externalBranches();
			}
		-|	If(x,y,z) ->> {
			return  x.externalBranches() + y.externalBranches() + z.externalBranches();
			}
		-|	Let(var, e, w) ->> {
			return  e.externalBranches() + w.externalBranches();
			}
		-|	BinaryOp(_,x,y) ->> {
			return  x.externalBranches() + y.externalBranches();
			}
		-|	UnaryOp(_,x) ->> {
			return  x.externalBranches();
			}
		-|	Cast(_,x) ->> {
			return  x.externalBranches();
			}
		-|	ElementAddress(x,y) ->> {
			return  ::externalBranches(x) + y.externalBranches();
			}
		-|	ValueExtract(_,x) ->> {
			return  x.externalBranches();
			}
		-|	CallLibraryFunction(_,_,x) ->> {
			return  ::externalBranches(x);
			}
		-|	Continuations(x,data) ->> {
			return  ::externalBranches(x);
			}
		-|	Call(t,h,a) ->> {
			return  t.externalBranches() + ::externalBranches(h) + ::externalBranches(a);
			}
		-|	Jump(_,e) ->> {
			return  ::externalBranches(e);
			}
		-|	FollowContinuation(v,c,i) ->> {
			return  v.externalBranches() + c.externalBranches();
			}
		-|	Return(_,v) ->> {
			return  v.externalBranches();
			}
		-|	Halt() ->> {
			return  emptyTreeSet();
			}
		;
	}


template<class T1, class T2>
ImmutableTreeSet<uword_t>	exits(const pair<T1, T2>& inExpr)
	{
	return exits(inExpr.first) + exits(inExpr.second);
	}

template<class T>
ImmutableTreeSet<uword_t>	exits(const Nullable<T>& inExpr)
	{
	if (inExpr)
		return exits(*inExpr);
	return ImmutableTreeSet<uword_t>();
	}

ImmutableTreeSet<uword_t>	exits(const ImmutableTreeVector<NativeExpression>& inExpr)
	{
	ImmutableTreeSet<uword_t> tr;
	for (long k = 0; k < inExpr.size();k++)
		tr = tr + inExpr[k].exits();
	return tr;
	}

ImmutableTreeSet<uword_t>	exits(const ImmutableTreeVector<NativeContinuation>& inExpr)
	{
	ImmutableTreeSet<uword_t> tr;
	for (long k = 0; k < inExpr.size();k++)
		tr = tr + inExpr[k].exits();
	return tr;
	}
ImmutableTreeSet<uword_t>			NativeExpression::computeExits(void) const
	{
	@match NativeExpression(*this)
		-|	Constant(v) ->> {
			return  emptyTreeSet();
			}
		-|	Variable(v) ->> {
			return  emptyTreeSet();
			}
		-|	Tagged(e) ->> {
			return  e.exits();
			}
		-|	CreateComposite(x) ->> {
			return  ::exits(x);
			}
		-|	DiscardFirst(x,y) ->> {
			return  x.exits() + y.exits();
			}
		-|	Load(x) ->> {
			return  x.exits();
			}
		-|	Zero() ->> {
			return  emptyTreeSet();
			}
		-|	Alloc(_, x) ->> {
			return emptyTreeSet();
			}
		-|	Store(x,y) ->> {
			return  x.exits() + y.exits();
			}
		-|	Selector(x,y,z) ->> {
			return  x.exits() + y.exits() + z.exits();
			}
		-|	If(x,y,z) ->> {
			return  x.exits() + y.exits() + z.exits();
			}
		-|	Let(var, e, w) ->> {
			return  e.exits() + w.exits();
			}
		-|	BinaryOp(_,x,y) ->> {
			return  x.exits() + y.exits();
			}
		-|	UnaryOp(_,x) ->> {
			return  x.exits();
			}
		-|	Cast(_,x) ->> {
			return  x.exits();
			}
		-|	ElementAddress(x,y) ->> {
			return  ::exits(x) + y.exits();
			}
		-|	ValueExtract(_,x) ->> {
			return  x.exits();
			}
		-|	CallLibraryFunction(_,_,x) ->> {
			return  ::exits(x);
			}
		-|	Continuations(x,data) ->> {
			return  ::exits(x);
			}
		-|	Call(t,h,a) ->> {
			return  t.exits() + ::exits(h) + ::exits(a);
			}
		-|	Jump(_,e) ->> {
			return  ::exits(e);
			}
		-|	FollowContinuation(v,c,i) ->> {
			return  v.exits() + c.exits();
			}
		-|	Return(ix,v) ->> {
			return  v.exits() + (uword_t)ix;
			}
		-|	Halt() ->> {
			return  emptyTreeSet();
			}
		;
	}
NativeBlockID NativeBlockID::internal(void)
	{
	static AO_t ix = 1000000000000;
	return NativeBlockID(true, AO_fetch_and_add_full(&ix, 1));
	}
NativeBlockID NativeBlockID::external(void)
	{
	static AO_t ix = 1000000000000;
	return NativeBlockID(false, AO_fetch_and_add_full(&ix, 1));
	}
NativeBlockID NativeBlockID::external(uword_t branch)
	{
	return NativeBlockID(false, branch);
	}
NativeBlockID NativeBlockID::entry(void)
	{
	return NativeBlockID(false, 0);
	}
ImmutableTreeSet<string>	NativeContinuation::externalBranches(void) const
	{
	return expression().externalBranches();
	}
ImmutableTreeSet<uword_t>	NativeContinuation::exits(void) const
	{
	return expression().exits();
	}

template<class T>
uint64_t complexity(const ImmutableTreeVector<T>& x)
	{
	uint64_t tr = 0;
	for (long k = 0; k < x.size();k++)
		tr = tr + x[k].complexity();
	return tr;
	}
template<class T>
uint64_t height(const ImmutableTreeVector<T>& x)
	{
	uint64_t tr = 0;
	for (long k = 0; k < x.size();k++)
		tr = std::max(tr, x[k].height());
	return tr + 1;
	}
uint64_t	NativeContinuation::complexity(void) const
	{
	return expression().complexity();
	}
uint64_t	NativeContinuation::height(void) const
	{
	return expression().height();
	}
uint64_t									NativeExpression::computeComplexity(void) const
	{
	@match NativeExpression(*this)
		-|	Constant() ->> {
			return  1;
			}
		-|	Variable(var) ->> {
			return  1;
			}
		-|	CreateComposite(x) ->> {
			return  ::complexity(x);
			}
		-|	DiscardFirst(a,b) ->> {
			return  a.complexity() + b.complexity();
			}
		-|	Tagged(e) ->> {
			return  e.complexity();
			}
		-|	Load(x) ->> {
			return  x.complexity() + 1;
			}
		-|	Zero(t) ->> {
			return  1;
			}
		-|	Alloc(t, count) ->> {
			return 1;
			}
		-|	Store(x,y) ->> {
			return  1 + x.complexity() + y.complexity();
			}
		-|	Selector(a,x,y) ->> {
			return  a.complexity() + y.complexity() + x.complexity();
			}
		-|	If(x,y,z) ->> {
			return  x.complexity() + y.complexity() + z.complexity();
			}
		-|	Let(a,x,y) ->> {
			return  x.complexity() + y.complexity() + 1;
			}
		-|	BinaryOp(_,x,y) ->> {
			return  x.complexity() + y.complexity();
			}
		-|	UnaryOp(_,x) ->> {
			return  x.complexity();
			}
		-|	Cast(t,x) ->> {
			return  x.complexity() + 1;
			}
		-|	ElementAddress(x,y) ->> {
			return  ::complexity(x) + y.complexity() + 1;
			}
		-|	ValueExtract(_,x) ->> {
			return  x.complexity();
			}
		-|	CallLibraryFunction(_,_,e) ->> {
			return  ::complexity(e) + 1;
			}
		-|	Continuations(continuations) ->> {
			return  ::complexity(continuations);
			}
		-|	Call(f,r,args) ->> {
			return  f.complexity() + ::complexity(r) + ::complexity(args);
			}
		-|	Jump(l,e) ->> {
			return  ::complexity(e);
			}
		-|	FollowContinuation(x,y,i) ->> {
			return  x.complexity() + y.complexity();
			}
		-|	Return(_,e) ->> {
			return  e.complexity();
			}
		-|	Halt() ->> {
			return  1;
			}
		;
	}
uint64_t									NativeExpression::computeHeight(void) const
	{
	@match NativeExpression(*this)
		-|	Constant() ->> {
			return  1;
			}
		-|	Variable(var) ->> {
			return  1;
			}
		-|	CreateComposite(x) ->> {
			return  ::height(x)+1;
			}
		-|	DiscardFirst(a,b) ->> {
			return  std::max(a.height(), b.height()) + 1;
			}
		-|	Tagged(e) ->> {
			return  e.height();
			}
		-|	Load(x) ->> {
			return  x.height() + 1;
			}
		-|	Zero(t) ->> {
			return  1;
			}
		-|	Alloc(t, count) ->> {
			return 1;
			}
		-|	Store(x,y) ->> {
			return  std::max(x.height(), y.height());
			}
		-|	Selector(a,x,y) ->> {
			return  std::max(std::max(a.height(),y.height()),x.height()) + 1;
			}
		-|	If(x,y,z) ->> {
			return  std::max(std::max(x.height(),y.height()),z.height()) + 1;
			}
		-|	Let(a,x,y) ->> {
			return  std::max(x.height(),y.height()) + 1;
			}
		-|	BinaryOp(_,x,y) ->> {
			return  std::max(x.height(),y.height()) + 1;
			}
		-|	UnaryOp(_,x) ->> {
			return  x.height();
			}
		-|	Cast(t,x) ->> {
			return  x.height() + 1;
			}
		-|	ElementAddress(x,y) ->> {
			return  std::max(::height(x),y.height()) + 1;
			}
		-|	ValueExtract(_,x) ->> {
			return  x.height() + 1;
			}
		-|	CallLibraryFunction(_,_,e) ->> {
			return  ::height(e) + 1;
			}
		-|	Continuations(continuations) ->> {
			return  ::height(continuations);
			}
		-|	Call(f,r,args) ->> {
			return  std::max(std::max(f.height(),::height(r)),::height(args)) + 1;
			}
		-|	Jump(l,e) ->> {
			return  ::height(e);
			}
		-|	FollowContinuation(x,y,i) ->> {
			return  std::max(x.height(),y.height()) + 1;
			}
		-|	Return(_,e) ->> {
			return  e.height();
			}
		-|	Halt() ->> {
			return  1;
			}
		;
	}
uint64_t NativeCFG::complexity(void) const
	{
	uint64_t tr = 0;
	for (long k = 0; k < size();k++)
		tr = tr + (*this)[k].expression().complexity();
	return tr;
	}
uint64_t NativeCFG::height(void) const
	{
	uint64_t tr = 0;
	for (long k = 0; k < size();k++)
		tr = std::max(tr, (*this)[k].expression().height());
	return tr+1;
	}

NativeExpression NativeExpression::printf(std::string s, ImmutableTreeVector<NativeExpression> arguments, bool toStdErr)
	{
	return NativeExpression::CallLibraryFunction("fprintf", NativeType::Nothing(), emptyTreeVec()  +
		NativeExpression::ConstantULong(
			(unsigned long)(toStdErr ? stderr : stdout)
			) +
		TypedFora::Abi::ArbitraryNativeConstantForString::expressionForString(s)
		+ arguments
		);
	}

NativeContinuation NativeContinuation::addTeardown(NativeExpression e) const
	{
	@match NativeContinuation(*this)
		-| (v,r,f,meta) ->> {
			return NativeContinuation(v,e>>r,f,meta);
			};
	}
uint64_t NativeCallTarget::complexity(void) const
	{
	@match NativeCallTarget(*this)
		-| 	Expansion() ->> {
			return 30;
			}
		-|	Inline(f) ->> {
			return  f.complexity() + 1;
			}
		-|	External() ->> {
			return  30;
			}
		-|	Pointer(x) ->> {
			return x.complexity() + 30;
			}
		;
	}
uint64_t NativeCallTarget::height(void) const
	{
	@match NativeCallTarget(*this)
		-|  Expansion() ->> {
			return 1;
			}
		-|	Inline(f) ->> {
			return  f.height() + 1;
			}
		-|	External() ->> {
			return  1;
			}
		-|	Pointer(x) ->> {
			return x.height() + 1;
			}
		;
	}
NativeExpression NativeExpression::Alloc(NativeType t, uword_t ct)
	{
	return NativeExpression::Alloc(t, ct, false);
	}

NativeExpression NativeExpression::taggedWith(
				const NativeExpressionTag& t) const
	{
	return NativeExpression::Tagged(*this, t);
	}
NativeExpression NativeExpression::taggedWith(
				const Nullable<NativeExpressionTag>& t) const
	{
	if (!t)
		return *this;
	return NativeExpression::Tagged(*this, *t);
	}

NativeExpression	NativeCFG::operator()(const ImmutableTreeVector<NativeExpression>& inExprs) const
	{
	if (returnTypes().size() == 1)
		{
		return NativeExpression::Call(
			NativeCallTarget::Inline(
				*this,
				NativeBlockID::entry()
				),
			emptyTreeVec() + NativeContinuation(returnTypes()[0]),
			inExprs,
			emptyTreeVec()
			);
		}
	else
		{
		ImmutableTreeVector<NativeContinuation> conts;
		for (long k = 0; k < returnTypes().size();k++)
			conts = conts + NativeContinuation::Return(returnTypes()[k], k);

		return NativeExpression::Call(
			NativeCallTarget::Inline(
				*this,
				NativeBlockID::entry()
				),
			conts,
			inExprs,
			emptyTreeVec()
			);
		}
	}
NativeExpression	NativeCFG::operator()(const ImmutableTreeVector<NativeExpression>& inExprs, const ImmutableTreeVector<NativeContinuation>& conts) const
	{
	return NativeExpression::Call(NativeCallTarget::Inline(*this, NativeBlockID::entry()), conts, inExprs, emptyTreeVec());
	}
NativeExpression	NativeCFG::operator()(void) const
	{
	return (*this)(emptyTreeVec());
	}
NativeExpression	NativeCFG::operator()(const NativeExpression& e1) const
	{
	return (*this)(emptyTreeVec() + e1);
	}
NativeExpression	NativeCFG::operator()(const NativeExpression& e1, const NativeExpression& e2) const
	{
	return (*this)(emptyTreeVec() + e1 + e2);
	}
NativeExpression	NativeCFG::operator()(const NativeExpression& e1, const NativeExpression& e2, const NativeExpression& e3) const
	{
	return (*this)(emptyTreeVec() + e1 + e2 + e3);
	}
NativeExpression	NativeCFG::operator()(const NativeExpression& e1, const NativeExpression& e2, const NativeExpression& e3, const NativeExpression& e4) const
	{
	return (*this)(emptyTreeVec() + e1 + e2 + e3 + e4);
	}
NativeExpression	NativeCFG::operator()(const NativeExpression& e1, const NativeExpression& e2, const NativeExpression& e3, const NativeExpression& e4, const NativeExpression& e5) const
	{
	return (*this)(emptyTreeVec() + e1 + e2 + e3 + e4 + e5);
	}
Nullable<uint64_t> NativeExpression::integerConstant(void) const
	{
	@match NativeExpression(*this)
		-| Constant(UInt8(x)) ->> {
			return null() << uint64_t(x);
			}
		-| Constant(UInt16(x)) ->> {
			return null() << uint64_t(x);
			}
		-| Constant(UInt32(x)) ->> {
			return null() << uint64_t(x);
			}
		-| Constant(UInt64(x)) ->> {
			return null() << uint64_t(x);
			}
		-| _ ->> {
			return null();
			}
		;
	}

NativeType		NativeCFG::implicitContinuationArgType(void) const
	{
	ImmutableTreeVector<NativeType> types;
	for (long k = 0; k < returnTypes().size();k++)
		types = types + returnTypes()[k];
	return NativeType::Continuations(types);
	}

NativeExpression NativeExpression::Let(const NativeVariable& var,
						   const NativeExpression& expr,
						   const NativeExpression& within
						   )
	{
	if (expr.type())
		lassert_dump(var.type() == *expr.type(),
			"invalid let binding. can't assign expression "
				<< prettyPrintString(expr) << "\nof type "
				<< prettyPrintString(*expr.type()) << " to variable of type "
				<< prettyPrintString(var.type()) << " within \n"
				<< prettyPrintString(within)
				);
	return Let(var, expr, within, false);
	}
NativeExpression		NativeExpression::If(const NativeExpression& condition, const NativeExpression& ifTrue, const NativeExpression& ifFalse)
	{
	return NativeExpression::If(condition, ifTrue, ifFalse, .5);
	}
NativeExpression
		NativeExpression::Loop(
					const NativeVariable& var,
					const NativeExpression& initializer,
					const NativeExpression& condition,
					const NativeExpression& body,
					const NativeExpression& update,
					const NativeExpression& result,
					double conditionFrequency
					)
	{
	NativeBlockID block = NativeBlockID::entry();

	return NativeExpression::Call(
		NativeCallTarget::Inline(
			NativeCFG(
				emptyTreeVec() + *result.type(),
				emptyTreeMap() + block +
					NativeBlock(emptyTreeVec() + var,
						NativeExpression::If(
							condition,
							body >> NativeExpression::Jump(block, emptyTreeVec() + update),
							NativeExpression::Return(0, result),
							conditionFrequency
							)
						)
					)
				,
			block
			),
		emptyTreeVec() +
			NativeContinuation(*result.type())
			,
		emptyTreeVec() +
			initializer,
		emptyTreeVec()
		);
	}
NativeExpression		NativeExpression::Loop(const ImmutableTreeVector<NativeVariable>& var, const ImmutableTreeVector<NativeExpression>& initializer, const NativeExpression& condition, const NativeExpression& body, const ImmutableTreeVector<NativeExpression>& update, const NativeExpression& result)
	{
	NativeBlockID block = NativeBlockID::entry();

	return NativeExpression::Call(
		NativeCallTarget::Inline(
			NativeCFG(
				emptyTreeVec() + *result.type(),
				emptyTreeMap() + block +
					NativeBlock(var,
						NativeExpression::If(
							condition,
							body >> NativeExpression::Jump(block, update),
							NativeExpression::Return(0, result)
							)
						)
					)
				,
			block
			),
		emptyTreeVec() +
			NativeContinuation(*result.type())
			,
		initializer,
		emptyTreeVec()
		);
	}

NativeContinuation::NativeContinuation(NativeType t)
	{
	var() = NativeVariable::Temp(t);
	relativeFrequency() = 1.0;
	expression() = var().expr();
	}

const ImmutableTreeVector<NativeVariable>& NativeCFG::args(NativeBlockID block) const
	{
	return blocks()[block]->args();
	}

NativeExpression	wrapInLetStatements(
		const ImmutableTreeVector<pair<NativeVariable, NativeExpression> >& lets,
		const NativeExpression& expr
		)
	{
	NativeExpression tr = expr;
	for (long k = ((long)lets.size())-1; k>=0; k--)
		tr = NativeExpression::Let(
			lets[k].first,
			lets[k].second,
			tr
			);
	return tr;
	}



NativeExpression NativeExpression::elemPtr(uword_t offset) const
	{
	return ElementAddress(
		emptyTreeVec() +
			NativeExpression::ConstantUInt32(offset),
		*this
		);
	}
NativeExpression NativeExpression::elemPtr(
			uword_t offset,
			uword_t offset2
			) const
	{
	return ElementAddress(
		emptyTreeVec() +
			NativeExpression::ConstantUInt32(offset) +
			NativeExpression::ConstantUInt32(offset2),
		*this
		);
	}
NativeExpression NativeExpression::elemPtr(
			uword_t offset,
			uword_t offset2,
			uword_t offset3
			) const
	{
	return ElementAddress(
		emptyTreeVec() +
			NativeExpression::ConstantUInt32(offset) +
			NativeExpression::ConstantUInt32(offset2) +
			NativeExpression::ConstantUInt32(offset3),
		*this
		);
	}

NativeExpression NativeExpression::operator[](const std::string& inName) const
	{
	lassert(type());

	@match NativeType(*type())
		-| Pointer(Composite(elements, names)) ->> {
			for (long k = 0; k < names.size();k++)
				if (names[k] && *names[k] == inName)
					return elemPtr(0, k);
			}
		-| Composite(elements, names) ->> {
			for (long k = 0; k < names.size();k++)
				if (names[k] && *names[k] == inName)
					return extract(k);
			}
		-| _ ->> {
			}
		;

	lassert_dump(false,
		"Can't find "
			<< inName << " as a valid name in type "
			<< prettyPrintString(*type())
			<< " while trying to use operator[]"
		);
	}

NativeExpression NativeExpression::operator[](uword_t offset) const
	{
	if (type() && type()->isPointer())
		return elemPtr(offset);
	else
		{
		@match NativeExpression(*this)
			-| ValueExtract(args, expr) ->> {
				return NativeExpression::ValueExtract(args + offset, expr);
				}
			-| _ ->> {
				return extract(offset);
				}
		}
	}

NativeExpression NativeExpression::operator[](NativeExpression offset) const
	{
	return ElementAddress(emptyTreeVec() + offset, *this);
	}
NativeExpression NativeExpression::operator[](ImmutableTreeVector<NativeExpression> offset) const
	{
	return ElementAddress(offset, *this);
	}
NativeExpression NativeExpression::load(bool isVolatile) const
	{
	return NativeExpression::Load(*this, isVolatile);
	}
NativeExpression NativeExpression::operator+(const NativeExpression& e) const
	{
	return BinaryOp(NativeBinaryOpcode::Add(), *this, e);
	}
NativeExpression NativeExpression::operator-(const NativeExpression& e) const
	{
	return BinaryOp(NativeBinaryOpcode::Sub(), *this, e);
	}
NativeExpression NativeExpression::operator*(const NativeExpression& e) const
	{
	return BinaryOp(NativeBinaryOpcode::Mul(), *this, e);
	}
NativeExpression NativeExpression::operator/(const NativeExpression& e) const
	{
	return BinaryOp(NativeBinaryOpcode::Div(), *this, e);
	}
NativeExpression NativeExpression::operator%(const NativeExpression& e) const
	{
	return BinaryOp(NativeBinaryOpcode::Mod(), *this, e);
	}
NativeExpression NativeExpression::extract(ImmutableTreeVector<uword_t> elts) const
	{
	@match NativeExpression(*this)
		-| ValueExtract(args, expr) ->>  {
			return ValueExtract(args + elts, *this);
			}
		-| _ ->> {
			return ValueExtract(elts, *this);
			}
	}
NativeExpression NativeExpression::extract(uword_t elts) const
	{
	return ValueExtract(emptyTreeVec() + elts, *this);
	}
NativeExpression NativeExpression::store(NativeExpression val) const
	{
	if (val.type() && val.type()->isEmpty())
		return NativeExpression::Nothing();

	return Store(*this, val);
	}

NativeExpression operator!=(const NativeExpression& lhs, const NativeExpression& rhs)
	{
	return NativeExpression::BinaryOp(NativeBinaryOpcode::NEQ(), lhs, rhs);
	}
NativeExpression operator==(const NativeExpression& lhs, const NativeExpression& rhs)
	{
	return NativeExpression::BinaryOp(NativeBinaryOpcode::EQ(), lhs, rhs);
	}
NativeExpression operator<(const NativeExpression& lhs, const NativeExpression& rhs)
	{
	return NativeExpression::BinaryOp(NativeBinaryOpcode::LT(), lhs, rhs);
	}
NativeExpression operator<=(const NativeExpression& lhs, const NativeExpression& rhs)
	{
	return NativeExpression::BinaryOp(NativeBinaryOpcode::LTE(), lhs, rhs);
	}
NativeExpression operator>(const NativeExpression& lhs, const NativeExpression& rhs)
	{
	return NativeExpression::BinaryOp(NativeBinaryOpcode::GT(), lhs, rhs);
	}
NativeExpression operator>=(const NativeExpression& lhs, const NativeExpression& rhs)
	{
	return NativeExpression::BinaryOp(NativeBinaryOpcode::GTE(), lhs, rhs);
	}

NativeExpression NativeExpression::ConstantPointer(void* u)
	{
	return NativeExpression::Constant(NativeConstant::VoidPtr((uword_t)u));
	}
NativeExpression NativeExpression::ConstantUInt8(uint8_t u)
	{
	return NativeExpression::Constant(NativeConstant::UInt8(u));
	}
NativeExpression NativeExpression::ConstantUInt16(uint16_t u)
	{
	return NativeExpression::Constant(NativeConstant::UInt16(u));
	}
NativeExpression NativeExpression::ConstantUInt32(uint32_t u)
	{
	return NativeExpression::Constant(NativeConstant::UInt32(u));
	}
NativeExpression NativeExpression::ConstantUInt64(uint64_t u)
	{
	return NativeExpression::Constant(NativeConstant::UInt64(u));
	}
NativeExpression NativeExpression::ConstantInt8(int8_t u)
	{
	return NativeExpression::Constant(NativeConstant::Int8(u));
	}
NativeExpression NativeExpression::ConstantInt16(int16_t u)
	{
	return NativeExpression::Constant(NativeConstant::Int16(u));
	}
NativeExpression NativeExpression::ConstantInt32(int32_t u)
	{
	return NativeExpression::Constant(NativeConstant::Int32(u));
	}
NativeExpression NativeExpression::ConstantInt64(int64_t u)
	{
	return NativeExpression::Constant(NativeConstant::Int64(u));
	}
NativeExpression NativeExpression::ConstantULong(uword_t u)
	{
	if (sizeof(uword_t) == 4)
		return NativeExpression::Constant(NativeConstant::UInt32(u));
	else
		return NativeExpression::Constant(NativeConstant::UInt64(u));
	}
NativeExpression NativeExpression::ConstantSLong(sword_t u)
	{
	if (sizeof(uword_t) == 4)
		return NativeExpression::Constant(NativeConstant::Int32(u));
	else
		return NativeExpression::Constant(NativeConstant::Int64(u));
	}
NativeExpression NativeExpression::Nothing()
	{
	return NativeExpression::Constant(NativeConstant::Nothing());
	}

namespace CPPML {

void Validator<NativeExpression_CallType, void>::operator()(NativeExpression_CallType& in) const
	{
	@match NativeCallTarget(in.f())
		-|	Expansion((name, nativeCfg)) ->> {
			NativeBlockID blockID = NativeBlockID::entry();

			//this is the empty NativeExpression::Call being produced by a serializer
			if (nativeCfg.size() == 0 && nativeCfg.returnTypes().size() == 0)
				return;

			const ImmutableTreeVector<NativeContinuation>& returnHandlers(in.returnHandlers());
			const ImmutableTreeVector<NativeType>& cfgReturnTypes(nativeCfg.returnTypes());
			const ImmutableTreeVector<NativeExpression>& args(in.args());

			lassert_dump(returnHandlers.size() >= nativeCfg.returnTypes().size(),
				"wrong number of return control flow paths for expansion call " << name << ": have "
					<< returnHandlers.size() << " continuations in the call, but the CFG returns "
					<< nativeCfg.returnTypes().size() << " paths."
				);

			for (long k = 0; k < nativeCfg.returnTypes().size();k++)
				lassert_dump(returnHandlers[k].var().type() == cfgReturnTypes[k],
					"cfg return slot " << k << " had type " <<
						prettyPrintString(cfgReturnTypes[k]) << " but handed continuation of type "
					<< prettyPrintString(returnHandlers[k].var().type()) << " in call of :\n" <<
					prettyPrintString(nativeCfg)
					);

			const NativeBlock& block = nativeCfg[blockID];

			bool valid = args.size() == block.args().size();
			for (long k = 0; k < args.size() && valid;k++)
				if (args[k].type() && block.args()[k].type() != *args[k].type())
					valid = false;

			if (!valid)
				{
				ostringstream str;
				str << "Invalid call operation. Block args are\n";
				for (long k = 0; k < block.args().size();k++)
					str << "\t" << prettyPrintString(block.args()[k].type()) << "\n";

				str << "\nwhile args are\n";

				for (long k = 0; k < args.size();k++)
					str << "\t" << prettyPrintString(args[k].type()) << " -- " << prettyPrintString(args[k]) << "\n";

				throw standardLogicErrorWithStacktrace("bad call for " + name + ": " + str.str());
				}
			}
		-|	Inline(nativeCfg, blockID) ->> {

			//this is the empty NativeExpression::Call being produced by a serializer
			if (nativeCfg.size() == 0 && nativeCfg.returnTypes().size() == 0)
				return;

			const ImmutableTreeVector<NativeContinuation>& returnHandlers(in.returnHandlers());
			const ImmutableTreeVector<NativeType>& cfgReturnTypes(nativeCfg.returnTypes());
			const ImmutableTreeVector<NativeExpression>& args(in.args());

			lassert_dump(returnHandlers.size() == nativeCfg.returnTypes().size(),
				"wrong number of return control flow paths for inline call"
				);

			for (long k = 0; k < returnHandlers.size();k++)
				lassert_dump(returnHandlers[k].var().type() == cfgReturnTypes[k],
					"cfg return slot " << k << " had type " <<
						prettyPrintString(cfgReturnTypes[k]) << " but handed continuation of type "
					<< prettyPrintString(returnHandlers[k].var().type()) << " in call of :\n" <<
					prettyPrintString(nativeCfg)
					);

			const NativeBlock& block = nativeCfg[blockID];

			bool valid = args.size() == block.args().size();
			for (long k = 0; k < args.size() && valid;k++)
				if (args[k].type() && block.args()[k].type() != *args[k].type())
					valid = false;

			if (!valid)
				{
				ostringstream str;
				str << "Invalid call operation. Block args are\n";
				for (long k = 0; k < block.args().size();k++)
					str << "\t" << prettyPrintString(block.args()[k].type()) << "\n";

				str << "\nwhile args are\n";

				for (long k = 0; k < args.size();k++)
					str << "\t" << prettyPrintString(args[k].type()) << " -- " << prettyPrintString(args[k]) << "\n";

				throw standardLogicErrorWithStacktrace("bad call: " + str.str());
				}
			}
		-|	_ ->> {}
	}

void Validator<NativeExpression_ValueExtractType, void>::operator()(NativeExpression_ValueExtractType& in) const
	{
	if (in.source().type())
		{
		lassert_dump(
			nativeTypeForValueExtractExpression(in.args(), *in.source().type()),
			"can't value extract from "
				<< prettyPrintString(*in.source().type())
				<< " with "
				<< prettyPrintString(in.args())
			);
		}

	@match NativeExpression(in.source())
		-| ValueExtract(subArgs, subSrc) ->> {

			//make copies, since we're going to destroy stuff when we copy them into 'in'
			ImmutableTreeVector<uword_t> newArgs = subArgs + in.args();
			NativeExpression newSrc = subSrc;

			in.args() = newArgs;
			in.source() = subSrc;
			}
		-| _ ->> {}
		;
	}

void Validator<NativeExpression_StoreType, void>::operator()(NativeExpression_StoreType& in) const
	{
	if (in.address().type() && in.valueToStore().type())
		{
		lassert_dump(
			*in.address().type() == in.valueToStore().type()->ptr() ||
				//allow the case created by the default constructor
				in.address().type()->isNothing() && in.valueToStore().type()->isNothing(),
			"can't store value of type "
				<< prettyPrintString(*in.valueToStore().type())
				<< " in pointer of type "
				<< prettyPrintString(*in.address().type())
			);
		}
	}



}

Nullable<NativeType> nativeTypeForValueExtractExpression(
											const ImmutableTreeVector<uword_t>& elements,
											const NativeType& sourceType
											)
	{
	NativeType t = sourceType;

	for (long k = 0; k < elements.size();k++)
		{
		@match NativeType(t)
			-|	Composite(elts) ->> {
					t = elts[elements[k]];
					}
			-|	Array(eltType, ct) ->> {
					t = eltType;
					}
			-|	_ ->> {
					return null();
					}
			;
		}

	return null() << t;
	}

NativeExpression NativeExpression::CallLibraryFunction(
							std::string functionName,
							const NativeType& retType,
							const ImmutableTreeVector<NativeExpression>& expressions
							)
	{
	return CallLibraryFunction(
				NativeLibraryFunctionTarget::ByName(functionName),
				retType,
				expressions,
				(emptyTreeVec() + false) * expressions.size(),
				false
				);
	}

NativeExpression NativeExpression::CallLibraryFunction(
							void* functionPointer,
							const NativeType& retType,
							const ImmutableTreeVector<NativeExpression>& expressions
							)
	{
	return CallLibraryFunction(
				NativeLibraryFunctionTarget::ByPointer((uword_t)functionPointer),
				retType,
				expressions,
				(emptyTreeVec() + false) * expressions.size(),
				false
				);
	}

NativeExpression operator&&(const NativeExpression& lhs, const NativeExpression& rhs)
	{
	return NativeExpression::BinaryOp(
		NativeBinaryOpcode::And(),
		lhs,
		rhs
		);
	}

NativeExpression operator||(const NativeExpression& lhs, const NativeExpression& rhs)
	{
	return NativeExpression::BinaryOp(
		NativeBinaryOpcode::Or(),
		lhs,
		rhs
		);
	}

NativeExpression NativeExpression::isNull() const
	{
	return *this == NativeExpression::Zero(*type());
	}

NativeExpression NativeExpression::isNotNull() const
	{
	return *this != NativeExpression::Zero(*type());
	}

void CPPMLPrettyPrint<NativeIndividualContinuationMetadata>::prettyPrint(
				CPPMLPrettyPrintStream& s,
				const NativeIndividualContinuationMetadata& t
				)
	{
	@match NativeIndividualContinuationMetadata(t)
		-| None() ->> {}
		-| ResumeWithResult(isException, type) ->> {
			s << "Resume(isException=" << (isException ? "true":"false");
			s << "," << type << ")";
			}
	}


