/***************************************************************************
   Copyright 2015 Ufora Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
****************************************************************************/
#include "ComputationState.hppml"
#include "ComputationEvent.hppml"
#include "../FORA/Runtime.hppml"
#include "../FORA/Interpreter/RuntimeConfig.hppml"
#include "../FORA/Core/PausedComputation.hppml"
#include "../FORA/Core/PausedComputationTree.hppml"
#include "../FORA/Core/TimeElapsed.hppml"
#include "../FORA/Core/ExecutionContextConfiguration.hppml"
#include "../FORA/Core/ExecutionContextImpl.hppml"
#include "../FORA/Core/ExecutionContextThreadStateTree.hppml"
#include "../FORA/Core/ExecutionContextMemoryPool.hppml"
#include "../FORA/Core/ValueDeepcopier.hppml"
#include "../FORA/Core/ImplValContainerUtilities.hppml"
#include "../FORA/Interpreter/InterpreterThreadObserver.hppml"
#include "../core/Logging.hpp"
#include "../core/threading/CallbackScheduler.hppml"
#include "../FORA/VectorDataManager/PageRefcountTracker.hppml"
#include "../FORA/VectorDataManager/BigVectorSliceSet.hppml"
#include "../FORA/TypedFora/ABI/BigVectorLayouts.hppml"
#include "../FORA/Serialization/ForaValueSerializationStream.hppml"
#include "../core/PolymorphicSharedPtrBinder.hpp"
#include "SystemwideComputationScheduler/ThreadGroup.hppml"
#include "SystemwideComputationScheduler/RuntimePrediction/RuntimePredictionValue.hppml"
#include "SystemwideComputationScheduler/RuntimePrediction/RuntimePredictionSignature.hppml"

using Fora::Interpreter::TimeElapsed;
using Fora::Interpreter::ExecutionContext;
using Fora::Interpreter::PausedComputation;
using Fora::Interpreter::PausedComputationTree;
using Fora::Interpreter::PausedComputationTreeSplit;

const double kMinTimeInCompiledCodeToDisableTracing = .1;

const double kSmallTimeInterval = 0.001;

static hash_type computationStateHashIncrement = hash_type::SHA1("ComputationStateIncrement");

namespace Cumulus {

class ComputationStateValuesOutsideOfExecutionContext {
public:
	ComputationStateValuesOutsideOfExecutionContext(
								PolymorphicSharedPtr<VectorDataManager> inVDM,
								ComputationId inId
								) : 
			mRefcountKeepaliveExecutionContext(inVDM),
			mId(inId)
		{
		mRefcountKeepaliveExecutionContext.disableMemoryPoolDefragment();
		mRefcountKeepaliveExecutionContext.setMemoryPoolPageSize(
			inVDM->getMemoryManager()->getVerySmallAllocSize()
			);
		}

	~ComputationStateValuesOutsideOfExecutionContext()
		{
		mUnconsumedDefinition = null();
		mConsumedDefinition = null();
		mPartialComputationResults.clear();
		mSplitComputation = null();
		mPendingCacheResult = null();
		mExternalIoTaskResult = null();

		if (mRefcountKeepaliveExecutionContext.getMemoryPool()->totalBytesAllocated() > 0)
			{
			LOG_CRITICAL << "ComputationStateValuesOutsideOfExecutionContext has "
				<< mRefcountKeepaliveExecutionContext.getMemoryPool()->totalBytesAllocated() 
				<< " bytes still allocated.";
			}
		}

	ImmutableTreeSet<Fora::BigVectorId> getReferencedBigVectors()
		{
		return mRefcountKeepaliveExecutionContext.getReferencedBigVectors();
		}

	MemoryPool* getMemoryPool() const
		{
		return mRefcountKeepaliveExecutionContext.getMemoryPool();
		}

	const Nullable<Fora::Interpreter::ComputationResult> & getExternalIoTaskResult() const
		{
		return mExternalIoTaskResult;
		}

	const Nullable<ComputationDefinition>& getUnconsumedDefinition() const
		{
		return mUnconsumedDefinition;
		}

	const Nullable<ComputationDefinition>& getConsumedDefinition() const
		{
		return mConsumedDefinition;
		}

	const map<ComputationId, pair<Fora::Interpreter::ComputationResult, TimeElapsed> >& getPartialComputationResults() const
		{
		return mPartialComputationResults;
		}

	const Nullable<ImmutableTreeVector<PausedComputationTreeSplit> >& getSplitComputation() const
		{
		return mSplitComputation;
		}

	const Nullable<Fora::Interpreter::ComputationResult>& getPendingCacheResult() const
		{
		return mPendingCacheResult;
		}

	const pair<Fora::Interpreter::ComputationResult, TimeElapsed>& 
				getPartialComputationResult(const ComputationId& inId) const
		{
		auto it = mPartialComputationResults.find(inId);
		lassert(it != mPartialComputationResults.end());

		return it->second;
		}

	void setUnconsumedDefinition(const ComputationDefinition& definition)
		{
		mUnconsumedDefinition = copyToKeepalive(definition);
		}

	void clearUnconsumedDefinition()
		{
		if (mUnconsumedDefinition && !mUnconsumedDefinition->isTemporary())
			mConsumedDefinition = mUnconsumedDefinition;

		mUnconsumedDefinition = null();
		}

	void placeUnconsumedDefinitionIntoConsumedDefinition()
		{
		mConsumedDefinition = mUnconsumedDefinition;
		mUnconsumedDefinition = null();

		mPartialComputationResults.clear();
		mSplitComputation = null();
		mPendingCacheResult = null();
		}

	void placeConsumedDefinitionIntoUnconsumedDefinition()
		{
		mUnconsumedDefinition = mConsumedDefinition;
		mConsumedDefinition = null();

		mPartialComputationResults.clear();
		mSplitComputation = null();
		mPendingCacheResult = null();
		}

	void becomePassthroughTo()
		{
		if (mUnconsumedDefinition && !mUnconsumedDefinition->isTemporary())
			placeUnconsumedDefinitionIntoConsumedDefinition();
			else
		if (mConsumedDefinition)
			{
			mUnconsumedDefinition = null();
			mPartialComputationResults.clear();
			mSplitComputation = null();
			mPendingCacheResult = null();
			}
		else
			clear();
		}

	void setSplitComputation(const ImmutableTreeVector<PausedComputationTreeSplit>& comp)
		{
		mSplitComputation = copyToKeepalive(comp);
		}

	void clearSplitComputation()
		{
		mSplitComputation = null();
		}

	void clearPendingCacheResult()
		{
		mPendingCacheResult = null();
		}

	void setPendingCacheResult(Fora::Interpreter::ComputationResult in)
		{
		mPendingCacheResult = copyToKeepalive(in);
		}

	void clearExternalIoTaskResult()
		{
		mExternalIoTaskResult = null();
		}

	void setExternalIoTaskResult(Fora::Interpreter::ComputationResult value)
		{
		}

	void setExternalIoTaskResult(ExternalIoTaskResult result)
		{
		@match ExternalIoTaskResult(result)
			-| Success() ->> {
				mExternalIoTaskResult = Fora::Interpreter::ComputationResult::Result(
					ImplValContainer(),
					ImplValContainer()
					);
				}
			-| TaskResultAsForaValue(computationResult) ->> {
				mExternalIoTaskResult = copyToKeepalive(computationResult);
				}
			-| S3KeyDoesNotExist() ->> {
				mExternalIoTaskResult = 
					Fora::Interpreter::ComputationResult::Exception(
						ImplValContainerUtilities::createString(
							String(
								"No such key exists", 
								mRefcountKeepaliveExecutionContext.getMemoryPool()
								)
							),
						ImplValContainer()
						);
				}
			-| S3PermissionError() ->> {
				mExternalIoTaskResult = 
					Fora::Interpreter::ComputationResult::Exception(
						ImplValContainerUtilities::createString(
							String(
								"S3 credentials error", 
								mRefcountKeepaliveExecutionContext.getMemoryPool()
								)
							),
						ImplValContainer()
						);
				}
            -| UserCausedPythonFailure(reason) ->> {
                mExternalIoTaskResult =
                    Fora::Interpreter::ComputationResult::Exception(
                        ImplValContainerUtilities::createString(
                            String(
                                reason,
                                mRefcountKeepaliveExecutionContext.getMemoryPool()
                                )
                            ),
                        ImplValContainer()
                        );
                }
			-| _ ->> {
				mExternalIoTaskResult = Fora::Interpreter::ComputationResult::Failure(
					Fora::Interpreter::ErrorState::IllegalComputationState(
						prettyPrintString(result)
						)
					);
				}
		}

	bool hasExternalIoTaskResult()
		{
		return mExternalIoTaskResult.isValue();
		}

	void clearCompletely(std::string name = "")
		{
		mUnconsumedDefinition = null();
		mConsumedDefinition = null();
		mPartialComputationResults.clear();
		mSplitComputation = null();
		mPendingCacheResult = null();
		mExternalIoTaskResult = null();

		tryToTeardown_(name);
		}

	void clear(std::string name = "")
		{
		if (!mUnconsumedDefinition && !mConsumedDefinition)
			{
			clearCompletely(name);
			return;
			}

		ExecutionContext c(mRefcountKeepaliveExecutionContext.getVDM().polymorphicSharedPtrFromThis());

			{
			Nullable<ComputationDefinition> unconsumedDefinition;
			Nullable<ComputationDefinition> consumedDefinition;
			
			boost::shared_ptr<ValueDeepcopierState> state(new ValueDeepcopierState());
			unconsumedDefinition = copyTo(mUnconsumedDefinition, c.getMemoryPool(), *state);
			consumedDefinition = copyTo(mConsumedDefinition, c.getMemoryPool(), *state);
			state.reset();
				
			clearCompletely();

			state.reset(new ValueDeepcopierState());
			mUnconsumedDefinition = copyToKeepalive(unconsumedDefinition, *state);
			mConsumedDefinition = copyToKeepalive(consumedDefinition, *state);
			}
		}

	//this function is only used for testing. This function verifies that the contents of 
	//mRefcountKeepaliveExecutionContext consist only of the members of this function.
	void recycle(std::string name = "")
		{
		ExecutionContext c(mRefcountKeepaliveExecutionContext.getVDM().polymorphicSharedPtrFromThis());

		boost::shared_ptr<ValueDeepcopierState> state(new ValueDeepcopierState());
		auto v1 = copyTo(mUnconsumedDefinition, c.getMemoryPool(), *state);
		auto v2 = copyTo(mConsumedDefinition, c.getMemoryPool(), *state);
		auto v3 = copyTo(mPartialComputationResults, c.getMemoryPool(), *state);
		auto v4 = copyTo(mSplitComputation, c.getMemoryPool(), *state);
		auto v5 = copyTo(mPendingCacheResult, c.getMemoryPool(), *state);
		auto v6 = copyTo(mExternalIoTaskResult, c.getMemoryPool(), *state);
		state.reset();

		clearCompletely(name);

		state.reset(new ValueDeepcopierState());
		mUnconsumedDefinition = copyToKeepalive(v1, *state);
		mConsumedDefinition = copyToKeepalive(v2, *state);
		mPartialComputationResults = copyToKeepalive(v3, *state);
		mSplitComputation = copyToKeepalive(v4, *state);
		mPendingCacheResult = copyToKeepalive(v5, *state);
		mExternalIoTaskResult = copyToKeepalive(v6, *state);
		}

	bool hasPartialComputationResult(const ComputationId& inId)
		{
		return mPartialComputationResults.find(inId) != mPartialComputationResults.end();
		}

	void setPartialComputationResult(
			const ComputationId& inId, 
			Fora::Interpreter::ComputationResult result,
			TimeElapsed totalTimeElapsed
			)
		{
		mPartialComputationResults[inId] = make_pair(copyToKeepalive(result), totalTimeElapsed);
		}

	void clearPartialComputationResults()
		{
		mPartialComputationResults.clear();
		}

	void serialize(Fora::ForaValueSerializationStream& valueStream)
		{
		ValueDeepcopierState state;

		valueStream.serialize(copyToFreeStore(mUnconsumedDefinition, state));
		valueStream.serialize(copyToFreeStore(mConsumedDefinition, state));
		valueStream.serialize(copyToFreeStore(mPartialComputationResults, state));
		valueStream.serialize(copyToFreeStore(mSplitComputation, state));
		valueStream.serialize(copyToFreeStore(mPendingCacheResult, state));
		valueStream.serialize(copyToFreeStore(mExternalIoTaskResult, state));
		}

	void deserialize(Fora::ForaValueDeserializationStream& valueStream)
		{
		Nullable<ComputationDefinition> sUnconsumedDefinition;
		Nullable<ComputationDefinition> sConsumedDefinition;
		map<ComputationId, pair<Fora::Interpreter::ComputationResult, TimeElapsed> > sPartialComputationResults;
		Nullable<ImmutableTreeVector<PausedComputationTreeSplit> > sSplitComputation;
		Nullable<Fora::Interpreter::ComputationResult> sPendingCacheResult;
		Nullable<Fora::Interpreter::ComputationResult> sExternalIoTaskResult;

		valueStream.deserialize(sUnconsumedDefinition);
		valueStream.deserialize(sConsumedDefinition);
		valueStream.deserialize(sPartialComputationResults);
		valueStream.deserialize(sSplitComputation);
		valueStream.deserialize(sPendingCacheResult);
		valueStream.deserialize(sExternalIoTaskResult);

		ValueDeepcopierState state;

		mUnconsumedDefinition = copyToKeepalive(sUnconsumedDefinition, state);
		mConsumedDefinition = copyToKeepalive(sConsumedDefinition, state);
		mPartialComputationResults = copyToKeepalive(sPartialComputationResults, state);
		mSplitComputation = copyToKeepalive(sSplitComputation, state);
		mPendingCacheResult = copyToKeepalive(sPendingCacheResult, state);
		mExternalIoTaskResult = copyToKeepalive(sExternalIoTaskResult, state);
		}

	void disableVectorPaging()
		{
		mRefcountKeepaliveExecutionContext.disableVectorPaging();
		}

	void enableVectorPaging()
		{
		mRefcountKeepaliveExecutionContext.enableVectorPaging();
		}

	uint64_t totalBytesAllocated()
		{
		return mRefcountKeepaliveExecutionContext.getMemoryPool()->totalBytesAllocated();
		}

	uint64_t totalBytesAllocatedFromOS()
		{
		return mRefcountKeepaliveExecutionContext.getMemoryPool()->totalBytesAllocatedFromOS();
		}

private:	
	template<class T>
	static T copyToFreeStore(const T& in)
		{
		return copyTo(in, MemoryPool::getFreeStorePool());
		}

	template<class T>
	T copyToKeepalive(const T& in)
		{
		return copyTo(in, mRefcountKeepaliveExecutionContext.getMemoryPool());
		}

	template<class T>
	T copyToKeepalive(const T& in, ValueDeepcopierState& state)
		{
		return copyTo(in, mRefcountKeepaliveExecutionContext.getMemoryPool(), state);
		}

	template<class T>
	static T copyToFreeStore(const T& in, ValueDeepcopierState& state)
		{
		return copyTo(in, MemoryPool::getFreeStorePool(), state);
		}

	template<class T>
	static T copyTo(const T& in, MemoryPool* pool)
		{
		ValueDeepcopierState state;
		return copyTo(in, pool, state);
		}

	template<class T>
	static T copyTo(const T& in, MemoryPool* pool, ValueDeepcopierState& state)
		{
		ValueDeepcopier deepcopier(
			state, 
			false, 
			pool, 
			false,
			false
			);

		return deepcopier.duplicate(in);
		}

	void tryToTeardown_(std::string name = "")
		{
		if (!mUnconsumedDefinition && 
				!mConsumedDefinition &&
				!mPartialComputationResults.size() && 
				!mSplitComputation && 
				!mPendingCacheResult
				)
			{
			if (mRefcountKeepaliveExecutionContext.getMemoryPool()->totalBytesAllocated() > 0)
				{
				LOG_ERROR << " still has bytes allocated: " << name 
					<< "\n" 
					<< "Total bytes: " 
					<< mRefcountKeepaliveExecutionContext.getMemoryPool()
						->totalBytesAllocatedFromOS() / 1024 / 1024.0 << " MB."
					<< "Total bytes in Pagelets: " 
					<< mRefcountKeepaliveExecutionContext.getExecutionContextMemoryPool()
						->totalBytesFromOSHeldInPagelets() / 1024 / 1024.0 << " MB."
					<< "\n" 
					<< Ufora::debug::StackTrace::getStringTrace()
					;
				}

			mRefcountKeepaliveExecutionContext.teardown();
			}
		}

	ComputationId mId;

	mutable ExecutionContext mRefcountKeepaliveExecutionContext;

	Nullable<ComputationDefinition> mUnconsumedDefinition;

	Nullable<ComputationDefinition> mConsumedDefinition;

	map<ComputationId, pair<Fora::Interpreter::ComputationResult, TimeElapsed> > mPartialComputationResults;

	Nullable<Fora::Interpreter::ComputationResult> mExternalIoTaskResult;

	Nullable<ImmutableTreeVector<PausedComputationTreeSplit> > mSplitComputation;

	Nullable<Fora::Interpreter::ComputationResult> mPendingCacheResult;
};

class ComputationStateImpl : public PolymorphicSharedPtrBase<ComputationStateImpl> {
public:
	ComputationStateImpl(
					const ComputationId& computationId,
					PolymorphicSharedPtr<VectorDataManager> inVDM,
					Fora::Interpreter::ExecutionContextConfiguration config,
					PolymorphicSharedPtr<CallbackScheduler> inCallbackScheduler
					) :
			mTimesReset(0),
			mTimesEverSplit(0),
			mOwnComputationId(computationId),
			mExecutionContext(new ExecutionContext(inVDM)),
			mOutsideEcValues(inVDM, computationId),
			mComputationStatus(ComputationStatus::Uninitialized()),
			mIsTemporary(false),
			mIsComputing(false),
			mIsRejoinedSplitThatHasNotComputed(false),
			mInterruptTriggered(false),
			mTimesComputedButMadeNoProgress(0),
			mIsPagingDisabled(false)
		{
		mExecutionContext->initialize();
		*mExecutionContext->getConfiguration() = config;

		mExecutionContext->setOnPageCreated(
				boost::bind(
					&ComputationStateImpl::onPageCreated,
					this,
					boost::arg<1>()
					)
				);
		}

	void clearCurrentState()
		{
		mComputationStatus = ComputationStatus::Uninitialized();
		mOutsideEcValues.clearCompletely();
		mPassthroughTo = null();
		mWasPassthroughTo = null();
		mBlockingComputationsInOrder.clear();
		mChildCheckpointStatuses.clear();
		mComputationStatisticsOutsideOfEC = ComputationStatistics();
		mIsComputing = false;
		mCurrentBlockingPages = emptyTreeSet();
		mTimeElapsedAtLastCompute = TimeElapsed();
		
			{
			boost::mutex::scoped_lock lock(mComputationEventsMutex);
			mComputationEvents.clear();
			}

		mExecutionContext->teardown();
		mExecutionContext->resetMemoryPoolPageSize();
		}

	template<class T>
	T copyToFreeStore(const T& in)
		{
		ValueDeepcopierState state;

		ValueDeepcopier deepcopier(state, false, MemoryPool::getFreeStorePool(), false, false);

		return deepcopier.duplicate(in);
		}

	~ComputationStateImpl()
		{
		//clear any values we may have placed into our temporary holding buffer
		mExecutionContext->teardown();
		}

	void onPageCreated(Fora::PageId inPageId)
		{
		boost::mutex::scoped_lock lock(mComputationEventsMutex);
		
		mComputationEvents.push_back(
			ComputationEvent::PageCreated(
				inPageId, 
				mExecutionContext->getTotalTimeElapsed().totalComputing()
				)
			);

		mComputationStatisticsOutsideOfEC.totalBytesPaged() += inPageId.bytecount();
		}

	static bool covers(ImmutableTreeSet<Fora::PageId> big, ImmutableTreeSet<Fora::PageId> smaller)
		{
		if (big.size() < smaller.size())
			return false;

		for (auto p: smaller)
			if (!big.contains(p))
				return false;
		return true;
		}

	const ComputationId& ownComputationId() const
		{
		return mOwnComputationId;
		}

	ComputationStatus currentComputationStatus()
		{
		return mComputationStatus;
		}

	void initialize(ComputationDefinition definition)
		{
		mIsTemporary = definition.isTemporary();

		mOutsideEcValues.clearCompletely();
		
		mComputationStatus = ComputationStatus::Computable();

		mBlockingComputationsInOrder.clear();
		mChildCheckpointStatuses.clear();

		mPassthroughTo = null();
		mWasPassthroughTo = null();

		mExecutionContext->teardown();
		mExecutionContext->resetInterruptState();
		
		mOutsideEcValues.setUnconsumedDefinition(definition);

		//import any values we can into the ExecutionContext
		resumeUnconsumedDefinition_(false);
		
		mTimesEverSplit = 0;

		mTimesReset++;
		}

	CreatedComputations compute(hash_type guid)
		{
		lassert(!mIsPagingDisabled);
		lassert(!mExecutionContext->isFinished());

		mComputationStatisticsOutsideOfEC.timesComputed() ++;

		mIsComputing = true;

		mComputingStartTime = curClock();

		CreatedComputations created = compute_(guid);

		mIsComputing = false;

		return created;
		}

	ImmutableTreeVector<ComputationEvent> extractRecentEvents()
		{
		boost::mutex::scoped_lock lock(mComputationEventsMutex);
		
		ImmutableTreeVector<ComputationEvent> result(mComputationEvents);
		mComputationEvents.clear();

		return result;
		}

	void unloadAllVectorHandles()
		{
		mExecutionContext->unloadAllVectorHandlesFromPool();
		}

	CreatedComputations compute_(hash_type guid)
		{
		mIsRejoinedSplitThatHasNotComputed = false;

		CreatedComputations computations;

		@match ComputationStatus(mComputationStatus)
			-|	Computable() ->> {
				while (true)
					{
					stepComputation_();

					if (!postComputationStateUpdate_(
							computations, 
							guid
							))
						{
						mInterruptTriggered = false;
						return computations;
						}

					if (mInterruptTriggered)
						{
						mInterruptTriggered = false;
						return computations;
						}

					if (!computations.isEmpty())
						return computations;
					}
				}
			-|	_ ->> {
				lassert_dump(
					false, 
					"doesn't make sense to 'compute' a thread in state " << mComputationStatus.tagName()
					);
				}
		}

	bool canResubmitBlockingThreads()
		{
		if (isBlockedOnExternalIoTask_())
			return false;

		for (auto b: mBlockingComputationsInOrder)
			if (b.isSplit())
				return false;

		return true;
		}

	CreatedComputations resubmitBlockingThreads(hash_type guid)
		{
		lassert(canResubmitBlockingThreads());
		lassert(!mOutsideEcValues.getSplitComputation());
		lassert(!isBlockedOnExternalIoTask_());

		if (mPassthroughTo)
			{
			ComputationDefinition def;

			if (!mOutsideEcValues.getUnconsumedDefinition())
				{
				lassert(mOutsideEcValues.getConsumedDefinition());

				def = *mOutsideEcValues.getConsumedDefinition();
				}
			else
				def = *mOutsideEcValues.getUnconsumedDefinition();

			CreatedComputations res;

			res.computations() = res.computations() + 
				*mPassthroughTo + def;

			return res;
			}

		mComputationStatisticsOutsideOfEC.timesComputationsLost() += 1;

		lassert_dump(
			mExecutionContext->isCacheRequest() || mOutsideEcValues.getUnconsumedDefinition(),
			prettyPrintString(mComputationStatus)
			);
		
		mBlockingComputationsInOrder.clear();
		mChildCheckpointStatuses.clear();

		mOutsideEcValues.clearPartialComputationResults();
		
		CreatedComputations computations;

		postComputationStateUpdate_(
			computations,
			guid
			);

		return computations;
		}

	bool isBlockedOnExternalIoTask_()
		{
		return mOutsideEcValues.hasExternalIoTaskResult() 
					|| mComputationStatus.isBlockedOnExternalIoTask();
		}

	ImmutableTreeVector<ComputationDefinition> currentUnconsumedDefinitionSubcomputations_()
		{
		@match ComputationDefinition(*mOutsideEcValues.getUnconsumedDefinition())
			-| Root(terms) ->> {
				ImmutableTreeVector<ComputationDefinition> defs;

				for (long k = 0; k < terms.size(); k++)
					@match ComputationDefinitionTerm(terms[k])
						-| Value(v, n) ->> {}
						-| Subcomputation(subcomputationTerms) ->> {
							defs = defs + ComputationDefinition::Root(subcomputationTerms);
							}

				return defs;
				}
			-| _ ->> {
				return emptyTreeVec();
				}
		}

	Fora::Interpreter::ComputationResult 
					assembleInitialEvaluate_(
						const ImmutableTreeVector<ComputationDefinitionTerm>& terms
						)
		{		
		ImmutableTreeVector<std::pair<ImplValContainer, Nullable<Symbol>>> arguments;
		
		long subdefsConsumed = 0;

		for (long k = 0; k < terms.size();k++)
			@match ComputationDefinitionTerm(terms[k])
				-| Value(v, n) ->> {
					arguments = arguments + std::make_pair(v, n);
					}
				-| Subcomputation(_) ->> {
					ComputationId subcompId = mBlockingComputationsInOrder[subdefsConsumed++];

					lassert_dump(
						mOutsideEcValues.hasPartialComputationResult(subcompId),
						"Partial computations are missing for " << prettyPrintString(subcompId)
						);

					@match Fora::Interpreter::ComputationResult(mOutsideEcValues.getPartialComputationResult(subcompId).first)
						-| Failure() ->> {
							return mOutsideEcValues.getPartialComputationResult(subcompId).first;
							}
						-| Exception() ->> {
							return mOutsideEcValues.getPartialComputationResult(subcompId).first;
							}
						-| Result(res, log) ->> {
							arguments = arguments + std::make_pair(res, null());
							}
					}
		
		return Fora::Interpreter::ComputationResult::Result(
			ImplValContainer(arguments),
			ImplValContainer()
			);
		}

	bool allComputationsHaveResults_()
		{
		for (auto it = mBlockingComputationsInOrder.begin(); 
					it != mBlockingComputationsInOrder.end(); ++it)
			if (!mOutsideEcValues.hasPartialComputationResult(*it))
				return false;

		return true;
		}

	//push the unconsumed definition forward if possible. if actuallyCalculate is false, then
	//place the computation in the ExecutionContext if possible, but don't execute any FORA code.
	void resumeUnconsumedDefinition_(bool actuallyCalculate)
		{
		bool wantsCalculate = false;

			{
			@match ComputationDefinition(*mOutsideEcValues.getUnconsumedDefinition())
				-| Root(terms) ->> {
					ImmutableTreeVector<ComputationDefinition> subdefs = 
						currentUnconsumedDefinitionSubcomputations_();

					if (subdefs.size() == 0 || 
								mBlockingComputationsInOrder.size() && allComputationsHaveResults_())
						{
						Fora::Interpreter::ComputationResult toCompute = assembleInitialEvaluate_(terms);

						mOutsideEcValues.clearPartialComputationResults();

						mBlockingComputationsInOrder.clear();
						mChildCheckpointStatuses.clear();

						@match Fora::Interpreter::ComputationResult(toCompute)
							-| Result(r, logs) ->> {
								mExecutionContext->placeInEvaluationState(r);

								mInitialRuntimePredictionSignature = 
									RuntimePredictionSignature::Root(
										RuntimePredictionValue::FromValue(
											r, 
											mExecutionContext->getVDM().polymorphicSharedPtrFromThis()
											)
										);

								if (actuallyCalculate)
									wantsCalculate = true;
								}
							-| _ ->> {
								mExecutionContext->setFinishedResult(toCompute);
								}
						}
					else
						{
						lassert_dump(
							mBlockingComputationsInOrder.size() == 0, 
							"Subdefs: " << prettyPrintString(subdefs) << "\n"
								<< "mPartialComputationResults: " 
									<< prettyPrintString(mOutsideEcValues.getPartialComputationResults()) << "\n"
								<< "mBlockingComputationsInOrder: " 
									<< prettyPrintString(mBlockingComputationsInOrder) << "\n"
							);

						return;
						}
					}	
				-| Split(parentId, pausedComputationTree) ->> {
					@match PausedComputationTree(pausedComputationTree)
						-| Thread(_, pausedComputation, _) ->> {
							if (pausedComputation.frames().size() == 1 && 
									pausedComputation.tail().isNone())
								mInitialRuntimePredictionSignature = 
									RuntimePredictionSignature::Split(
										hashValue(pausedComputation.frames()[0].graph()),
										pausedComputation.frames()[0].label(),
										RuntimePredictionValue::FromValue(
											pausedComputation.frames()[0].values(),
											mExecutionContext->getVDM().polymorphicSharedPtrFromThis()
											)
										);
							}
						-| _ ->> {}

					mExecutionContext->resumePausedComputation(pausedComputationTree);
					
					mBlockingComputationsInOrder.clear();
					mChildCheckpointStatuses.clear();

					if (actuallyCalculate)
						wantsCalculate = true;
					}
				;
			}

		if (mIsTemporary)
			mOutsideEcValues.clearUnconsumedDefinition();
		else
			mOutsideEcValues.placeUnconsumedDefinitionIntoConsumedDefinition();
		
		mOutsideEcValues.clear();

		if (wantsCalculate)
			{
			mExecutionContext->compute();
			updateBlockingPages_();
			}
		}

	void updateBlockingPages_()
		{
		mCurrentBlockingPages = mExecutionContext->getImpl()->getStats().pagesBlockedOn();
		mTimeElapsedAtLastCompute = mExecutionContext->getTotalTimeElapsed();

		std::set<Fora::PageId> pages;
		mExecutionContext->getImpl()->extractPagesTouched(pages);

		if (pages.size())
			{
			boost::mutex::scoped_lock lock(mComputationEventsMutex);

			for (auto p: pages)
				mComputationEvents.push_back(ComputationEvent::PageTouched(p));
			}
		}

	void stepComputation_(void)
		{
		mTimesComputedButMadeNoProgress++;

		if (mTimesComputedButMadeNoProgress > 10000)
			{
			LOG_ERROR << "triggered but made no progress " << mTimesComputedButMadeNoProgress
				<< ". mInterruptTriggered = " << (mInterruptTriggered?"true":"false")
				<< ". gate blocked? " << (
						mExecutionContext->getVDM().executionContextsCanRunGate().isOpen() ? 
							"false":"true"
						);
			}

		while (true)
			{
			auto& gate = mExecutionContext->getVDM().executionContextsCanRunGate();

			double t0 = curClock();

			while (!gate.blockUntilOpenWithTimeout(.01))
				{
				if (mInterruptTriggered)
					return;
				}

			if (mOutsideEcValues.getUnconsumedDefinition())
				resumeUnconsumedDefinition_(true);
				else 
			if (mOutsideEcValues.getPendingCacheResult())
				{
					{
					Fora::Interpreter::ComputationResult toResumeWith = *mOutsideEcValues.getPendingCacheResult();

					if (!mExecutionContext->isInterrupted())
						mTimesComputedButMadeNoProgress = 0;

					mExecutionContext->addCachecallResult(toResumeWith);
					mExecutionContext->compute();
					updateBlockingPages_();
					}

				mOutsideEcValues.clear();
				}
				else
			if (mOutsideEcValues.getSplitComputation())
				resumeSplitComputation();
				else
			if (mOutsideEcValues.hasExternalIoTaskResult())
				resumeExternalIoTaskResult_();
				else
			if (mBlockingComputationsInOrder.size())
				resumeCacheCall_();
			else
				{
				if (!mExecutionContext->isInterrupted())
					mTimesComputedButMadeNoProgress = 0;

				mExecutionContext->compute();
				updateBlockingPages_();
				}

			if (mExecutionContext->isInterrupted() && 
						!mExecutionContext->wasLastInterruptTriggeredExternally())
				{
				if (!mExecutionContext->resetInterruptStateIfOnlyTriggeredInternally())
					return;
				}
			else
				{
				//we're done here
				return;
				}
			}
		}

	void resumeSplitComputation()
		{
		assertAllComputationsCompleted_();

		mOutsideEcValues.clear();

		if (!mExecutionContext->isInterrupted())
			mTimesComputedButMadeNoProgress = 0;
			
		mExecutionContext->compute();
		updateBlockingPages_();
		}

	ImmutableTreeVector<ImplValContainer> extractCurrentLogs()
		{
		ImmutableTreeVector<ImplValContainer> result;

		return result;
		}

	ImmutableTreeVector<pair<ForaStackTrace, Fora::Interpreter::StackframeMetadata> > 
														extractStacktrace(bool extractValues)
		{
		ImmutableTreeVector<pair<ForaStackTrace, Fora::Interpreter::StackframeMetadata> >  result;

		return result;
		}

	void resumeExternalIoTaskResult_()
		{
		mTimesComputedButMadeNoProgress = 0;

		Fora::Interpreter::ComputationResult result = *mOutsideEcValues.getExternalIoTaskResult();

		if (result.isFailure())
			{
			mExecutionContext->setFinishedResult(result);
			}
		else
			{
			mExecutionContext->addCachecallResult(result);
			mExecutionContext->compute();
			updateBlockingPages_();
			}

		mOutsideEcValues.clearExternalIoTaskResult();
		}

	void resumeCacheCall_()
		{
		assertAllComputationsCompleted_();

			{
			ImmutableTreeVector<ImplValContainer> cacheResults;

			Nullable<Fora::Interpreter::ComputationResult> resultToUse;

			for (long k = 0; k < mBlockingComputationsInOrder.size() && !resultToUse; k++)
				{
				ComputationId id = mBlockingComputationsInOrder[k];
				pair<Fora::Interpreter::ComputationResult, TimeElapsed> result = 
					mOutsideEcValues.getPartialComputationResult(id);

				if (result.first.isFailure())
					resultToUse = result.first;
				}

			for (long k = 0; k < mBlockingComputationsInOrder.size() && !resultToUse; k++)
				{
				ComputationId id = mBlockingComputationsInOrder[k];
				Fora::Interpreter::ComputationResult result = 
					mOutsideEcValues.getPartialComputationResult(id).first;

				if (!result.isResult())
					{
					lassert(result.isException());
					resultToUse = result;
					}
				else
					{
					cacheResults = cacheResults + result.getResult().result();
					}

				}

			if (!resultToUse)
				resultToUse = Fora::Interpreter::ComputationResult::Result(
					ImplValContainer(cacheResults),
					ImplValContainer()
					);

			if (!mExecutionContext->isInterrupted())
				mTimesComputedButMadeNoProgress = 0;

			if (resultToUse->isFailure())
				mExecutionContext->setFinishedResult(*resultToUse);
			else
				{
				mExecutionContext->addCachecallResult(*resultToUse);
				mExecutionContext->compute();
				updateBlockingPages_();
				}
			}

		mOutsideEcValues.clear();
		mBlockingComputationsInOrder.clear();
		mChildCheckpointStatuses.clear();
		}

	void assertAllComputationsCompleted_()
		{
		lassert(!mBlockingComputationsInOrder.size());
		}

	bool postComputationStateUpdate_(CreatedComputations& ioComputations, hash_type& ioGuid)
		{
		if (mOutsideEcValues.getUnconsumedDefinition())
			{
			ImmutableTreeVector<ComputationDefinition> subdefs = 
					currentUnconsumedDefinitionSubcomputations_();

			lassert_dump(
				mBlockingComputationsInOrder.size() == 0, 
				prettyPrintString(mComputationStatus)
				);

			for (long k = 0; k < subdefs.size(); k++)
				{
				ComputationDefinition def = copyToFreeStore(subdefs[k]);

				ioGuid = ioGuid + computationStateHashIncrement;

				ComputationId subcompId = 
					ComputationId::CreateIdForRootOnWorker(
						def,
						ioGuid
						);

				ioComputations.computations() = ioComputations.computations() + subcompId + def;

				mBlockingComputationsInOrder.push_back(subcompId);
				}

			mComputationStatisticsOutsideOfEC.timesComputed()++;

			mComputationStatus = ComputationStatus::BlockedOnComputations(
				ImmutableTreeSet<ComputationId>(
					mBlockingComputationsInOrder.begin(),
					mBlockingComputationsInOrder.end()
					)
				);

			return false;
			}
			else
		if (mExecutionContext->isCacheRequest())
			{
			//it's possible that we entered the compute function with all subcomputations
			//completed, but didn't actually run computation (because gates are closed)
			//so that the computation is still in a 'cacheload' state
			if (mBlockingComputationsInOrder.size() && mOutsideEcValues.getPartialComputationResults().size())
				return false;

			CreatedComputations splitResult = tryToSplit(ioGuid);
			if (!splitResult.isEmpty())
				{
				ioComputations = splitResult;
				return false;
				}

			ImplValContainer cacheLoadRequest = mExecutionContext->getCacheRequest();

			if (isExternalIoTaskCacheLoad_(cacheLoadRequest))
				return stateChangeToExternalIoTaskCacheLoad_(
						cacheLoadRequest, 
						ioComputations,
						ioGuid
						);
				else
			if (isValidCacheLoad_(cacheLoadRequest))
				return stateChangeToRegularCacheLoad_(
						cacheLoadRequest, 
						ioComputations,
						ioGuid
						);
			else
				{
				mOutsideEcValues.setPendingCacheResult(
					Fora::Interpreter::ComputationResult::Exception(
						ImplValContainer(CSTValue("Badly formed cache argument")),
						ImplValContainer()
						)
					);
				return true;
				}
			}
		else
		if (mExecutionContext->isVectorLoad())
			{
			mComputationStatus = ComputationStatus::BlockedOnVectorLoad(
				mExecutionContext->getVDM().getBigVectorLayouts()
					->convertSliceToPages(mExecutionContext->getVectorLoad())
				);
			}
			else
		if (mExecutionContext->isFinished())
			{
			mExecutionContext->pageLargeVectorHandles(
				mIsTemporary ? 
					mExecutionContext->getVDM().maxPageSizeInBytes()
				:	mExecutionContext->getVDM().getMemoryManager()->getSlabSize()
				);

			if (!mOwnComputationId.isTemporary())
				LOG_DEBUG << "Computation " << mOwnComputationId.getRoot().computationHash()
					<< " / " << mOwnComputationId.guid()
					<< " finishing after "
					<< currentComputationStatistics().estimatedTotalRuntime()
					<< " seconds and references to "
					<< getReferencedBigVectors()
					;

			mComputationStatus = ComputationStatus::Finished();

			if (!mIsTemporary)
				mExecutionContext->setMemoryPoolPageSize(
					mExecutionContext->getVDM().getMemoryManager()->getVerySmallAllocSize()
					);
			}

		return false;
		}

	bool isExternalIoTaskCacheLoad_(ImplValContainer cacheLoadRequest)
		{
		if (!cacheLoadRequest.tupleGetSize())
			return false;

		if (*cacheLoadRequest.tupleGetSize() == 1)
			return (bool)convertImplValContainerToExternalIoTask(
				*cacheLoadRequest.tupleGetItem(0), 
				false
				);

		return false;
		}

	bool stateChangeToExternalIoTaskCacheLoad_(
				ImplValContainer cacheLoadRequest,
				CreatedComputations& computations,
				hash_type& ioGuid
				)
		{
		ExternalIoTask task;

		if (*cacheLoadRequest.tupleGetSize() == 1)
			task = *convertImplValContainerToExternalIoTask(
						*cacheLoadRequest.tupleGetItem(0), 
						false
						);
		else
			task = *convertImplValContainerToExternalIoTask(
						*cacheLoadRequest.tupleGetItem(1), 
						true
						);
		
		ioGuid = ioGuid + computationStateHashIncrement;
		ExternalIoTaskId taskId = ExternalIoTaskId(ioGuid);

		mComputationStatus = ComputationStatus::BlockedOnExternalIoTask(taskId);

		computations.ioTasks() = computations.ioTasks() + taskId + task;

		return false;
		}

	bool stateChangeToRegularCacheLoad_(
				ImplValContainer cacheLoadRequest,
				CreatedComputations& ioComputations,
				hash_type& ioGuid
				)
		{
		lassert(mBlockingComputationsInOrder.size() == 0);
		
		long tupleCt = *cacheLoadRequest.tupleGetSize();

		for (long k = 0; k < tupleCt; k++)
			{
			ImplValContainer elt = processCacheCallRequest_(*cacheLoadRequest.tupleGetItem(k));

			ioGuid = ioGuid + computationStateHashIncrement;

			ComputationDefinition def = 
				ComputationDefinition::ApplyFromTuple(
					copyToFreeStore(elt)
					);

			ComputationId computation = 
				ComputationId::CreateIdForRootOnWorker(
					def,
					ioGuid
					);

			ioComputations.computations() = 
				ioComputations.computations() + 
					computation + 
					def;

			mBlockingComputationsInOrder.push_back(computation);
			}
		
		mComputationStatisticsOutsideOfEC.timesComputed()++;

		mComputationStatus = ComputationStatus::BlockedOnComputations(
			ImmutableTreeSet<ComputationId>(
				mBlockingComputationsInOrder.begin(),
				mBlockingComputationsInOrder.end()
				)
			);

		return false;
		}

	ImplValContainer processCacheCallRequest_(const ImplValContainer& in)
		{
		//turn (agent, (*args)) into (agent, *args)
		ImplValContainer agent = *in.tupleGetItem(0);
		ImplValContainer args = *in.tupleGetItem(1);

		ImmutableTreeVector<ImplValContainer> allArgs;

		allArgs = allArgs + agent;

		allArgs = allArgs + ImplValContainer(CSTValue(Symbol("Call")));

		for (long k = 0; k < *args.tupleGetSize(); k++)
			allArgs = allArgs + *args.tupleGetItem(k);

		return ImplValContainer(allArgs);
		}

	bool isValidCacheLoad_(const ImplValContainer& cacheLoadRequest)
		{
		//cacheload should be a tuple of items, each of which looks like
		//(agent, (*args))

		if (!cacheLoadRequest.tupleGetSize())
			return false;

		long tupleCt = *cacheLoadRequest.tupleGetSize();

		if (tupleCt < 1)
			return false;

		for (long k = 0; k < tupleCt; k++)
			{
			ImplValContainer elt = *cacheLoadRequest.tupleGetItem(k);	

			if (!elt.tupleGetSize() || *elt.tupleGetSize() != 2)
				return false;

			ImplValContainer rhs = *elt.tupleGetItem(1);

			if (!rhs.tupleGetSize())
				return false;
			}

		return true;
		}

	void addComputationResult(const Cumulus::ComputationResult& inResult)
		{
		Fora::Interpreter::ComputationResult compResult;

		SerializedObject::deserialize(
			inResult.serializedInterpreterComputationResult(),
			mExecutionContext->getVDM().getMemoryManager(),
			compResult
			);

		addComputationResult(inResult.computation(), compResult, inResult.statistics());
		}


	void addComputationResult(
			ComputationId computation, 
			Fora::Interpreter::ComputationResult result,
			ComputationStatistics statistics
			)
		{
		if (mPassthroughTo)
			{
			auto& blockingOn = mOutsideEcValues.getPartialComputationResults();

			lassert_dump(
				blockingOn.size() == 1 && 
					blockingOn.find(*mPassthroughTo) != blockingOn.end(),
				"Computation " << prettyPrintString(mOwnComputationId) 
					<< " passthrough to "
					<< prettyPrintString(*mPassthroughTo)
					<< " is blocked on " << prettyPrintString(blockingOn)
					<< " instead of the passthrough"
				);

			mWasPassthroughTo = mPassthroughTo;

			mPassthroughTo = null();

			mExecutionContext->setFinishedResult(result);

			mOutsideEcValues.clear();

			mExecutionContext->pageLargeVectorHandles(
				mIsTemporary ? 
					mExecutionContext->getVDM().maxPageSizeInBytes()
				:	mExecutionContext->getVDM().getMemoryManager()->getSlabSize()
				);

			mComputationStatus = ComputationStatus::Finished();

			if (computation.isSplit())
				mComputationStatisticsOutsideOfEC = 
					ComputationStatistics::merge(
						mComputationStatisticsOutsideOfEC,
						statistics,
						false
						);

			if (!mOwnComputationId.isTemporary())
				LOG_DEBUG << "Computation " << mOwnComputationId.getRoot().computationHash() 
					<< " / " << mOwnComputationId.guid()
					<< " finishing after "
					<< currentComputationStatistics().estimatedTotalRuntime()
					<< " seconds and references to "
					<< getReferencedBigVectors()
					;

			return;
			}

		@match ComputationStatus(mComputationStatus)
			-| BlockedOnComputations(subthreads) ->> {
				long whichIndex = -1;
				for (long k = 0; k < mBlockingComputationsInOrder.size();k++)
					if (mBlockingComputationsInOrder[k] == computation)
						whichIndex = k;

				lassert_dump(whichIndex != -1, "received a split-result for a computation we dont think we own");

				mExecutionContext->absorbSplitResult(
					(*mOutsideEcValues.getSplitComputation())[whichIndex].computationHash(),
					result,
					TimeElapsed(
						statistics.timeSpentInInterpreter(),
						statistics.timeSpentInCompiler(),
						statistics.timeSpentGarbageCollecting()
						)
					);

				mComputationStatisticsOutsideOfEC.timesComputed()++;

				statistics.timeSpentInInterpreter() = 0;
				statistics.timeSpentInCompiler() = 0;
				statistics.timeSpentGarbageCollecting() = 0;
			
				mComputationStatisticsOutsideOfEC = 
					ComputationStatistics::merge(
						mComputationStatisticsOutsideOfEC,
						statistics,
						false
						);

				ImmutableTreeSet<ComputationId> newSubthreads = subthreads - computation;

				mBlockingComputationsInOrder.erase(mBlockingComputationsInOrder.begin() + whichIndex);
				
				mOutsideEcValues.setSplitComputation(
					mOutsideEcValues.getSplitComputation()->slice(0, whichIndex) + 
						mOutsideEcValues.getSplitComputation()->slice(whichIndex+1)
					);

				if (newSubthreads.size() == 0)
					{
					mComputationStatus = ComputationStatus::Computable();
					mIsRejoinedSplitThatHasNotComputed = false;
					mChildCheckpointStatuses.clear();
					mOutsideEcValues.clear();
					}
				else
					mComputationStatus = ComputationStatus::BlockedOnComputations(newSubthreads);
				}
			-| _ ->> {
				lassert_dump(false, 
					"Illegal to add a thread result for a thread in state " << 
						mComputationStatus.tagName()
					);
				}
		}

	void markExternalIoTaskCompleted(ExternalIoTaskCompleted completed)
		{
		mOutsideEcValues.setExternalIoTaskResult(completed.result());

		mComputationStatus = ComputationStatus::Computable();
		
		mIsRejoinedSplitThatHasNotComputed = false;
		}

	void markComputationCircular()
		{
		LOG_WARN << "Marking " << prettyPrintStringWithoutWrapping(mOwnComputationId) 
			<< " circular. Current state is "
			<< prettyPrintStringWithoutWrapping(mComputationStatus)
			;
		
		mExecutionContext->teardown();
		mOutsideEcValues.clearCompletely();
		mBlockingComputationsInOrder.clear();
		mChildCheckpointStatuses.clear();
		mPassthroughTo = null();
		mWasPassthroughTo = null();

		mExecutionContext->setFinishedResult(
			Fora::Interpreter::ComputationResult::Failure(
				Fora::Interpreter::ErrorState::IllegalComputationState(
					"Computation produced a circular reference."
					)
				)
			);
		mComputationStatus = ComputationStatus::Finished();
		}		

	void markSliceLoadFailedPermanently()
		{
		mExecutionContext->teardown();
		mExecutionContext->setFinishedResult(
			Fora::Interpreter::ComputationResult::Failure(
				Fora::Interpreter::ErrorState::IllegalComputationState(
					"PageLoad couldn't be completed due to an internal error."
					)
				)
			);
		mComputationStatus = ComputationStatus::Finished();
		mComputationStatisticsOutsideOfEC.timesComputed()++;
		}

	void markSliceLoaded()
		{
		@match ComputationStatus(mComputationStatus)
			-| BlockedOnVectorLoad(slice) ->> {
				mComputationStatus = ComputationStatus::Computable();
				}
			-| _ ->> {
				lassert_dump(false, 
					"Not blocked on a vectorload. state is " 
						<< prettyPrintString(mComputationStatus)
					);
				}
		}
	
	void resetInterruptState()
		{
		mExecutionContext->resetInterruptState();
		}

	void interrupt()
		{
		mInterruptTriggered = true;
		mExecutionContext->interrupt();
		}

	Nullable<Fora::Interpreter::ComputationResult> getResult()
		{
		@match ComputationStatus(mComputationStatus)
			-| Finished() ->> {
				return null() << mExecutionContext->getFinishedResult();
				}
			-| _ ->> {
				return null();
				}
		}

	PolymorphicSharedPtr<SerializedObject> getSerializedResult()
		{
		@match ComputationStatus(mComputationStatus)
			-| Finished() ->> {
				return SerializedObject::serialize(
					mExecutionContext->getFinishedResult(),
					mExecutionContext->getVDM().getMemoryManager()
					);
				}
			-| _ ->> {
				return PolymorphicSharedPtr<SerializedObject>();
				}
		}

	CreatedComputations tryToSplit(hash_type& ioGuid)
		{
		if (Runtime::getRuntime().getConfig().disableSplitting())
			return CreatedComputations();

		if (mIsRejoinedSplitThatHasNotComputed)
			return CreatedComputations();
		
		if (mExecutionContext->getInterpreterHistory().isTracing() && 
				curClock() - mExecutionContext->getInterpreterHistory().timeOfLastTraceEvent() < 
					kMinTimeInCompiledCodeToDisableTracing)
			{
			return CreatedComputations();
			}

		if (!canExtractPausedComputation())
			return CreatedComputations();

		ImmutableTreeVector<PausedComputationTreeSplit> computation;

		computation = mExecutionContext->splitComputation(true, mCurrentBlockingPages.size() > 10 ? 0.0 : 0.01);

		mComputationStatisticsOutsideOfEC.totalSplitCount() += 1;

		if (!computation.size())
			return CreatedComputations();

		mOutsideEcValues.setSplitComputation(computation);

		CreatedComputations computations =
			setStatusForSplitComputation(ioGuid);

		mExecutionContext->enableVectorPaging();

		return computations;
		}

	bool canExtractPausedComputation() const
		{
		return (mComputationStatus.isComputable() || mComputationStatus.isBlockedOnVectorLoad()) 
					&& !mOutsideEcValues.getUnconsumedDefinition();
		}

	CreatedComputations setStatusForSplitComputation(
				hash_type& ioGuid
				)
		{
		mBlockingComputationsInOrder.clear();
		mChildCheckpointStatuses.clear();

		mOutsideEcValues.clearPartialComputationResults();

		CreatedComputations result;

		auto createThread = [&](ComputationDefinition def) {
			ioGuid = ioGuid + computationStateHashIncrement;
			ComputationId id = ComputationId::CreateIdForSplit(def, ioGuid, mTimesEverSplit++);
			result.computations() = result.computations() + id + def;
			return id;
			};

		for (auto subcomp: *mOutsideEcValues.getSplitComputation())
			mBlockingComputationsInOrder.push_back(
				createThread(
					ComputationDefinition::Split(
						mOwnComputationId,
						copyToFreeStore(
							subcomp.childComputation()
							)
						)
					)
				);

		mComputationStatisticsOutsideOfEC.timesComputed()++;

		mComputationStatus = ComputationStatus::BlockedOnComputations(
			ImmutableTreeSet<ComputationId>(
				mBlockingComputationsInOrder.begin(),
				mBlockingComputationsInOrder.end()
				)
			);

		return result;
		}

	void pageLargeVectorHandles()
		{
		mExecutionContext->pageLargeVectorHandles(
			mExecutionContext->getVDM().maxPageSizeInBytes()
			);
		}

	Nullable<pair<CheckpointStatus, CheckpointRequest> > 
					setCheckpointStatusTimestamp(CheckpointRequest timestamp)
		{
		if (mCheckpointStatusTimestamp && timestamp < *mCheckpointStatusTimestamp)
			{
			//this can happen if we move a computation from a machine that had received a checkpoint
			//to a machine that hasn't
			LOG_DEBUG << "Can't set timestamp of " << mOwnComputationId << " backward-in-time to " << timestamp;
			return null();
			}

		mCheckpointStatusTimestamp = timestamp;

		return computeCurrentCheckpointStatus();
		}

	Nullable<pair<CheckpointStatus, CheckpointRequest> > 
					addChildComputationCheckpointStatus(
							ComputationId childComputation,
							CheckpointStatus stats,
							CheckpointRequest timestamp
							)
		{
		LOG_DEBUG << mOwnComputationId.guid() << " adding " << childComputation.guid() << " at " << timestamp;

		auto it = mChildCheckpointStatuses.find(childComputation);

		if (it == mChildCheckpointStatuses.end() || it->second.first < timestamp)
			mChildCheckpointStatuses[childComputation] = make_pair(timestamp, stats);

		return computeCurrentCheckpointStatus();
		}

	Nullable<pair<CheckpointStatus, CheckpointRequest> > 
					getCheckpointStatus() const
		{
		return mLastBroadcastCheckpointStatus;
		}

	Nullable<pair<CheckpointStatus, CheckpointRequest> > 
					computeCurrentCheckpointStatus()
		{
		//if we have no status ourselves
		if (!mCheckpointStatusTimestamp)
			return null();

		//if we have already broadcast
		if (mLastBroadcastCheckpointStatus && 
				mLastBroadcastCheckpointStatus->second == *mCheckpointStatusTimestamp)
			return null();

		CheckpointStatus result(
			currentComputationStatistics(), 
			getReferencedBigVectors()
			);

		if (mOwnComputationId.isRoot() && mExecutionContext->isFinished())
			result = result.withFinishedRootComputation();

		if (mOwnComputationId.isRoot() && (mPassthroughTo || mWasPassthroughTo))
			result = result.withPassthroughRootComputation();

		bool anyAreNotRepresented = false;
		for (auto c: mBlockingComputationsInOrder)
			{
			if (c.isRoot())
				{
				//pass - this is not a child we're going to count
				}
			else
				{
				if (mOutsideEcValues.hasPartialComputationResult(c))
					{
					//pass - stats already incorporated
					}
				else
					{
					auto it = mChildCheckpointStatuses.find(c);

					if (it == mChildCheckpointStatuses.end())
						{
						anyAreNotRepresented = true;
						}
					else
						{
						if (it->second.first != *mCheckpointStatusTimestamp)
							{
							anyAreNotRepresented = true;
							}
						else
							{
							result = CheckpointStatus::merge(result, it->second.second);
							}
						}
					}
				}
			}

		if (anyAreNotRepresented)
			return null();

		mChildCheckpointStatuses.clear();

		mLastBroadcastCheckpointStatus = make_pair(result, *mCheckpointStatusTimestamp);

		if (mCheckpointStatusTimestamp->writeToStorage())
			mLastPersistedCheckpointTimestamp = mCheckpointStatusTimestamp->timestamp();

		return mLastBroadcastCheckpointStatus;
		}

	PolymorphicSharedPtr<SerializedObject> serialize()
		{
		ONoncontiguousByteBlockProtocol				protocol;

		PolymorphicSharedPtr<SerializedObjectContext> context;
		
		context.reset(new SerializedObjectContext(mExecutionContext->getVDM().getMemoryManager()));
		
			{
			OBinaryStream stream(protocol);

			SerializedObjectContextSerializer serializer(stream, *context);

			Fora::VectorMemoizingForaValueSerializationStream valueStream(serializer);

			valueStream.serialize(mExecutionContext->isCacheRequest());
			valueStream.serialize(*mExecutionContext);
			valueStream.serialize(mComputationStatus);

			mOutsideEcValues.serialize(valueStream);
			
			valueStream.serialize(mBlockingComputationsInOrder);
			valueStream.serialize(mTimesEverSplit);
			valueStream.serialize(mInitialRuntimePredictionSignature);
			valueStream.serialize(mPassthroughTo);
			valueStream.serialize(mWasPassthroughTo);
			valueStream.serialize(mIsTemporary);
			valueStream.serialize(mComputationStatisticsOutsideOfEC);
			valueStream.serialize(mIsRejoinedSplitThatHasNotComputed);

			valueStream.serialize(mCurrentBlockingPages);
			valueStream.serialize(mTimeElapsedAtLastCompute);

			valueStream.serialize(mLastPersistedCheckpointTimestamp);
			valueStream.serialize(mCheckpointStatusTimestamp);
			valueStream.serialize(mLastBroadcastCheckpointStatus);
			valueStream.serialize(mChildCheckpointStatuses);

				{
				boost::mutex::scoped_lock lock(mComputationEventsMutex);
				valueStream.serialize(mComputationEvents);
				}

			valueStream.serialize(mIsPagingDisabled);
			valueStream.serialize(mTimesReset);
			}
		
		return PolymorphicSharedPtr<SerializedObject>(
			new SerializedObject(
				protocol.getData(),
				context
				)
			);
		}

	void deserialize(PolymorphicSharedPtr<SerializedObject> object)
		{
		//make sure nothing gets paged while we're in flight
		mExecutionContext->disableVectorPaging();
		mOutsideEcValues.disableVectorPaging();

		INoncontiguousByteBlockProtocol	protocol(object->getSerializedData());

		PolymorphicSharedPtr<SerializedObjectContext> context(
			new SerializedObjectContext(mExecutionContext->getVDM().getMemoryManager(), object)
			);
		
		IBinaryStream stream(protocol);

		SerializedObjectContextDeserializer deserializer(
			stream, 
			*context, 
			MemoryPool::getFreeStorePool()
			);

		Fora::VectorMemoizingForaValueDeserializationStream valueStream(deserializer);

		bool isCacheRequest;

		valueStream.deserialize(isCacheRequest);
		valueStream.deserialize(*mExecutionContext);
		valueStream.deserialize(mComputationStatus);

		mOutsideEcValues.deserialize(valueStream);

		valueStream.deserialize(mBlockingComputationsInOrder);
		valueStream.deserialize(mTimesEverSplit);
		valueStream.deserialize(mInitialRuntimePredictionSignature);
		valueStream.deserialize(mPassthroughTo);
		valueStream.deserialize(mWasPassthroughTo);
		valueStream.deserialize(mIsTemporary);
		valueStream.deserialize(mComputationStatisticsOutsideOfEC);
		valueStream.deserialize(mIsRejoinedSplitThatHasNotComputed);
		valueStream.deserialize(mCurrentBlockingPages);
		valueStream.deserialize(mTimeElapsedAtLastCompute);
		valueStream.deserialize(mLastPersistedCheckpointTimestamp);
		valueStream.deserialize(mCheckpointStatusTimestamp);
		valueStream.deserialize(mLastBroadcastCheckpointStatus);
		valueStream.deserialize(mChildCheckpointStatuses);
		valueStream.deserialize(mComputationEvents);
		valueStream.deserialize(mIsPagingDisabled);
		valueStream.deserialize(mTimesReset);

		if (mIsPagingDisabled)
			{
			mExecutionContext->disableVectorPaging();
			mOutsideEcValues.disableVectorPaging();
			}
		else
			{
			mExecutionContext->enableVectorPaging();
			mOutsideEcValues.enableVectorPaging();
			}


		if (isCacheRequest)
			lassert(mExecutionContext->isCacheRequest());

		mComputationStatisticsOutsideOfEC.timesMoved()++;
		mComputationStatisticsOutsideOfEC.timesMovedTimesBytesMoved() += 
													object->getSerializedData()->totalByteCount();

		if (mExecutionContext->isFinished() && !mIsTemporary)
			mExecutionContext->setMemoryPoolPageSize(
				mExecutionContext->getVDM().getMemoryManager()->getVerySmallAllocSize()
				);
		}
	
	void becomePassthroughTo(ComputationId inId)
		{
		LOG_INFO << "Computation " 
			<< prettyPrintStringWithoutWrapping(mOwnComputationId) << " becoming passthrough to "
			<< prettyPrintStringWithoutWrapping(inId)
			;

		mTimesEverSplit = 0;

		mTimesReset++;

		if (computeCurrentTimeElapsed() > 1.0)
			LOG_WARN << "Becoming passthrough with stats=" << 
				prettyPrintString(currentComputationStatistics());
		
		mExecutionContext->teardown();

		mOutsideEcValues.becomePassthroughTo();

		mComputationStatus = ComputationStatus::BlockedOnComputations(emptyTreeSet() + inId);
		mBlockingComputationsInOrder.clear();
		mBlockingComputationsInOrder.push_back(inId);
		mComputationStatisticsOutsideOfEC = ComputationStatistics();
		mIsRejoinedSplitThatHasNotComputed = false;

		mPassthroughTo = inId;
		}

	bool isPassthrough() const
		{
		return mPassthroughTo.isValue();
		}

	bool isTemporary() const
		{
		return mIsTemporary;
		}
	
	void interruptAfterCycleCount(sword_t checks)
		{
		mExecutionContext->interruptAfterCycleCount(checks);
		}

	ImmutableTreeSet<Fora::BigVectorId> getReferencedBigVectors()
		{
		return mExecutionContext->getReferencedBigVectors() + 
			mOutsideEcValues.getReferencedBigVectors();
		}

	ComputationStatistics currentComputationStatistics() const
		{
		return 
			ComputationStatistics::merge(
				mComputationStatisticsOutsideOfEC,
				computationStatisticsForEC(),
				true
				).withTimesReset(mTimesReset)
				.withInitialRuntimePrediction(mInitialRuntimePredictionSignature);
		}

	//this function is not safe to be called from another thread while we are computing
	ComputationStatistics computationStatisticsForEC() const
		{
		return ComputationStatistics(
			mInitialRuntimePredictionSignature,
			mTimeElapsedAtLastCompute.timeSpentInInterpreter(),
			mTimeElapsedAtLastCompute.timeSpentInCompiledCode(),
			mTimeElapsedAtLastCompute.timeSpentGarbageCollecting(),
			0,
			0,
			//min memory used is 4096, a single page, which is a crude proxy for the 
			//fact that we're allocating cumulus data structures etc.
			std::max<int64_t>(
				mExecutionContext->getMemoryUsageAtLastEvent().first + 
					mOutsideEcValues.getMemoryPool()->totalBytesAllocated(),
				4096
				),
			std::max<int64_t>(
				mExecutionContext->getMemoryUsageAtLastEvent().second + 
					mOutsideEcValues.getMemoryPool()->totalBytesAllocatedFromOS(),
				4096
				),
			0,
			0,
			0,
			0,
			mCurrentBlockingPages,
			0
			);
		}

	double computeCurrentTimeElapsed() const
		{
		double timeElapsed = 0;

		if (mIsComputing)
			timeElapsed += curClock() - mComputingStartTime;

		timeElapsed +=
			mExecutionContext->getTotalTimeElapsed().timeSpentInInterpreter() + 
			mExecutionContext->getTotalTimeElapsed().timeSpentInCompiledCode() + 
			mExecutionContext->getTotalTimeElapsed().timeSpentGarbageCollecting()
			;

		return timeElapsed;
		}

	void disableVectorPaging()
		{
		mIsPagingDisabled = true;
		mExecutionContext->disableVectorPaging();
		mOutsideEcValues.disableVectorPaging();
		}

	void enableVectorPaging()
		{
		mIsPagingDisabled = false;
		mExecutionContext->enableVectorPaging();
		mOutsideEcValues.enableVectorPaging();
		}

	void resetStateForAddDrop()
		{
		if (mComputationStatus.isBlockedOnVectorLoad())
			{
			//we'll just retry later
			markSliceLoaded();
			return;
			}

		@match ComputationStatus(mComputationStatus)
			-| BlockedOnExternalIoTask() ->> {
				mOutsideEcValues.clearExternalIoTaskResult();
				mComputationStatus = ComputationStatus::Computable();
				}
			-| _ ->> {}
			;
		}

	Nullable<RuntimePredictionSignature> getRuntimePredictionSignature()
		{
		return mInitialRuntimePredictionSignature;
		}

private:
	Nullable<double> mLastPersistedCheckpointTimestamp;

	Nullable<CheckpointRequest> mCheckpointStatusTimestamp;

	Nullable<pair<CheckpointStatus, CheckpointRequest> > mLastBroadcastCheckpointStatus;

	map<ComputationId, pair<CheckpointRequest, CheckpointStatus> > mChildCheckpointStatuses;

	long mTimesComputedButMadeNoProgress;

	bool mIsRejoinedSplitThatHasNotComputed;

	bool mInterruptTriggered;

	bool mIsPagingDisabled;

	int32_t mTimesReset;

	int64_t mTimesEverSplit;

	ComputationId mOwnComputationId;

	ComputationStatus mComputationStatus;

	Nullable<RuntimePredictionSignature> mInitialRuntimePredictionSignature;

	ComputationStateValuesOutsideOfExecutionContext mOutsideEcValues;

	PolymorphicSharedPtr<ExecutionContext> mExecutionContext;

	Nullable<ComputationId> mPassthroughTo;

	Nullable<ComputationId> mWasPassthroughTo;

	std::vector<ComputationId> mBlockingComputationsInOrder;

	bool mIsTemporary;

	ComputationStatistics mComputationStatisticsOutsideOfEC;

	bool mIsComputing;

	double mComputingStartTime;

	ImmutableTreeSet<Fora::PageId> mCurrentBlockingPages;

	std::vector<ComputationEvent> mComputationEvents;

	boost::mutex mComputationEventsMutex;

	TimeElapsed mTimeElapsedAtLastCompute;
};


ComputationState::ComputationState(
						const ComputationId& computationId,
						PolymorphicSharedPtr<VectorDataManager> inVDM,
						Fora::Interpreter::ExecutionContextConfiguration config,
						PolymorphicSharedPtr<CallbackScheduler> inCallbackScheduler
						)
	{
	mImpl.reset(
		new ComputationStateImpl(
			computationId, 
			inVDM, 
			config,
			inCallbackScheduler
			)
		);
	}

const ComputationId& ComputationState::ownComputationId() const
	{
	return mImpl->ownComputationId();
	}

PolymorphicSharedPtr<SerializedObject> ComputationState::serialize()
	{
	return mImpl->serialize();
	}

void ComputationState::deserialize(PolymorphicSharedPtr<SerializedObject> inObject)
	{
	mImpl->deserialize(inObject);
	}

void ComputationState::initialize(ComputationDefinition definition)
	{
	mImpl->initialize(definition);
	}

CreatedComputations ComputationState::compute(hash_type guid)
	{
	return mImpl->compute(guid);
	}

void ComputationState::interrupt()
	{
	mImpl->interrupt();
	}

ComputationStatus ComputationState::currentComputationStatus()
	{
	return mImpl->currentComputationStatus();
	}

ComputationStatistics ComputationState::currentComputationStatistics()
	{
	return mImpl->currentComputationStatistics();
	}


PolymorphicSharedPtr<SerializedObject> ComputationState::getSerializedResult()
	{
	return mImpl->getSerializedResult();
	}

Nullable<Fora::Interpreter::ComputationResult> ComputationState::getResult()
	{
	return mImpl->getResult();
	}

CreatedComputations ComputationState::tryToSplit(hash_type guid)
	{
	return mImpl->tryToSplit(guid);
	}

void ComputationState::addComputationResult(const Cumulus::ComputationResult& inResult)
	{
	mImpl->addComputationResult(inResult);
	}

void ComputationState::addComputationResult(
			ComputationId computation, 
			Fora::Interpreter::ComputationResult result,
			ComputationStatistics statistics
			)
	{
	mImpl->addComputationResult(computation, result, statistics);
	}

void ComputationState::markSliceLoaded()
	{
	mImpl->markSliceLoaded();
	}

void ComputationState::markComputationCircular()
	{
	mImpl->markComputationCircular();
	}

void ComputationState::markSliceLoadFailedPermanently()
	{
	mImpl->markSliceLoadFailedPermanently();
	}

bool ComputationState::canExtractPausedComputation() const
	{
	return mImpl->canExtractPausedComputation();
	}

CreatedComputations ComputationState::resubmitBlockingThreads(hash_type guid)
	{
	return mImpl->resubmitBlockingThreads(guid);
	}

bool ComputationState::canResubmitBlockingThreads()
	{
	return mImpl->canResubmitBlockingThreads();
	}

void ComputationState::resetInterruptState()
	{
	mImpl->resetInterruptState();
	}

void ComputationState::becomePassthroughTo(ComputationId inId)
	{
	mImpl->becomePassthroughTo(inId);
	}

bool ComputationState::isPassthrough() const
	{
	return mImpl->isPassthrough();
	}

bool ComputationState::isTemporary() const
	{
	return mImpl->isTemporary();
	}

void ComputationState::interruptAfterCycleCount(sword_t checks)
	{
	mImpl->interruptAfterCycleCount(checks);
	}

ImmutableTreeSet<Fora::BigVectorId> ComputationState::getReferencedBigVectors()
	{
	return mImpl->getReferencedBigVectors();
	}
		
ImmutableTreeVector<ImplValContainer> ComputationState::extractCurrentLogs()
	{
	return mImpl->extractCurrentLogs();
	}

ImmutableTreeVector<pair<ForaStackTrace, Fora::Interpreter::StackframeMetadata> >
										ComputationState::extractStacktrace(bool extractValues)
	{
	return mImpl->extractStacktrace(extractValues);
	}

void ComputationState::pageLargeVectorHandles()
	{
	mImpl->pageLargeVectorHandles();
	}
	
void ComputationState::disableVectorPaging()
	{
	mImpl->disableVectorPaging();
	}

void ComputationState::enableVectorPaging()
	{
	mImpl->enableVectorPaging();
	}

void ComputationState::markExternalIoTaskCompleted(ExternalIoTaskCompleted completed)
	{
	return mImpl->markExternalIoTaskCompleted(completed);
	}

void ComputationState::unloadAllVectorHandles()
	{
	mImpl->unloadAllVectorHandles();
	}

ImmutableTreeVector<ComputationEvent> ComputationState::extractRecentEvents()
	{
	return mImpl->extractRecentEvents();
	}

Nullable<pair<CheckpointStatus, CheckpointRequest> > 
				ComputationState::setCheckpointStatusTimestamp(CheckpointRequest timestamp)
	{
	return mImpl->setCheckpointStatusTimestamp(timestamp);
	}

Nullable<pair<CheckpointStatus, CheckpointRequest> > 
				ComputationState::getCheckpointStatus()
	{
	return mImpl->getCheckpointStatus();
	}

Nullable<pair<CheckpointStatus, CheckpointRequest> > 
				ComputationState::addChildComputationCheckpointStatus(
						ComputationId childComputation,
						CheckpointStatus stats,
						CheckpointRequest timestamp
						)
	{
	return mImpl->addChildComputationCheckpointStatus(childComputation, stats, timestamp);
	}

void ComputationState::resetStateForAddDrop()
	{
	mImpl->resetStateForAddDrop();
	}

Nullable<RuntimePredictionSignature> ComputationState::getRuntimePredictionSignature()
	{
	return mImpl->getRuntimePredictionSignature();
	}
}

